/*
    generated by jscc, an LALR(1) parser generator made by hadroncfy.
    template for typescript, written by hadroncfy, aussi.
*/


/*
    find the next state to go in the dfa
*/
function moveDFA0(c: number, ret: { state: number, hasArc: boolean, isEnd: boolean }){
    switch(ret.state){
        case 0:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c >= 9 && c <= 10 || c === 13 || c === 32){
                ret.state = 1;
            }
            else if(c === 34){
                ret.state = 2;
            }
            else if(c === 47){
                ret.state = 3;
            }
            else if(c === 104){
                ret.state = 4;
            }
            else {
                ret.state = -1;
            }
            break;
        case 1:
            ret.hasArc = true;
            ret.isEnd = true;
            if(c >= 9 && c <= 10 || c === 13 || c === 32){
                ret.state = 1;
            }
            else {
                ret.state = -1;
            }
            break;
        case 2:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c <= 9 || c >= 11 && c <= 33 || c >= 35 && c <= 91 || c >= 93){
                ret.state = 5;
            }
            else if(c === 34){
                ret.state = 6;
            }
            else if(c === 92){
                ret.state = 7;
            }
            else {
                ret.state = -1;
            }
            break;
        case 3:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c === 42){
                ret.state = 8;
            }
            else if(c === 47){
                ret.state = 9;
            }
            else {
                ret.state = -1;
            }
            break;
        case 4:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c === 107){
                ret.state = 10;
            }
            else {
                ret.state = -1;
            }
            break;
        case 5:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c <= 9 || c >= 11 && c <= 33 || c >= 35 && c <= 91 || c >= 93){
                ret.state = 5;
            }
            else if(c === 34){
                ret.state = 6;
            }
            else if(c === 92){
                ret.state = 7;
            }
            else {
                ret.state = -1;
            }
            break;
        case 6:
            ret.hasArc = false;
            ret.isEnd = true;
            ret.state = -1;
            break;
        case 7:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c === 34 || c === 39 || c === 92 || c === 110 || c === 116){
                ret.state = 11;
            }
            else if(c === 117 || c === 120){
                ret.state = 12;
            }
            else {
                ret.state = -1;
            }
            break;
        case 8:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c <= 41 || c >= 43 && c <= 46 || c >= 48){
                ret.state = 13;
            }
            else if(c === 42){
                ret.state = 14;
            }
            else if(c === 47){
                ret.state = 15;
            }
            else {
                ret.state = -1;
            }
            break;
        case 9:
            ret.hasArc = true;
            ret.isEnd = true;
            if(c <= 9 || c >= 11){
                ret.state = 16;
            }
            else {
                ret.state = -1;
            }
            break;
        case 10:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c === 109){
                ret.state = 17;
            }
            else {
                ret.state = -1;
            }
            break;
        case 11:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c <= 9 || c >= 11 && c <= 33 || c >= 35 && c <= 91 || c >= 93){
                ret.state = 5;
            }
            else if(c === 34){
                ret.state = 6;
            }
            else if(c === 92){
                ret.state = 7;
            }
            else {
                ret.state = -1;
            }
            break;
        case 12:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c >= 48 && c <= 57 || c >= 65 && c <= 70 || c >= 97 && c <= 102){
                ret.state = 18;
            }
            else {
                ret.state = -1;
            }
            break;
        case 13:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c <= 41 || c >= 43 && c <= 46 || c >= 48){
                ret.state = 13;
            }
            else if(c === 42){
                ret.state = 14;
            }
            else if(c === 47){
                ret.state = 19;
            }
            else {
                ret.state = -1;
            }
            break;
        case 14:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c <= 46 || c >= 48){
                ret.state = 20;
            }
            else if(c === 47){
                ret.state = 21;
            }
            else {
                ret.state = -1;
            }
            break;
        case 15:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c === 47){
                ret.state = 22;
            }
            else {
                ret.state = -1;
            }
            break;
        case 16:
            ret.hasArc = true;
            ret.isEnd = true;
            if(c <= 9 || c >= 11){
                ret.state = 16;
            }
            else {
                ret.state = -1;
            }
            break;
        case 17:
            ret.hasArc = false;
            ret.isEnd = true;
            ret.state = -1;
            break;
        case 18:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c <= 9 || c >= 11 && c <= 33 || c >= 35 && c <= 47 || c >= 58 && c <= 64 || c >= 71 && c <= 91 || c >= 93 && c <= 96 || c >= 103){
                ret.state = 5;
            }
            else if(c === 34){
                ret.state = 6;
            }
            else if(c >= 48 && c <= 57 || c >= 65 && c <= 70 || c >= 97 && c <= 102){
                ret.state = 23;
            }
            else if(c === 92){
                ret.state = 7;
            }
            else {
                ret.state = -1;
            }
            break;
        case 19:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c <= 41 || c >= 43 && c <= 46 || c >= 48){
                ret.state = 13;
            }
            else if(c === 42){
                ret.state = 14;
            }
            else if(c === 47){
                ret.state = 19;
            }
            else {
                ret.state = -1;
            }
            break;
        case 20:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c <= 41 || c >= 43 && c <= 46 || c >= 48){
                ret.state = 13;
            }
            else if(c === 42){
                ret.state = 14;
            }
            else if(c === 47){
                ret.state = 15;
            }
            else {
                ret.state = -1;
            }
            break;
        case 21:
            ret.hasArc = false;
            ret.isEnd = true;
            ret.state = -1;
            break;
        case 22:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c <= 41 || c >= 43 && c <= 46 || c >= 48){
                ret.state = 13;
            }
            else if(c === 42){
                ret.state = 14;
            }
            else if(c === 47){
                ret.state = 15;
            }
            else {
                ret.state = -1;
            }
            break;
        case 23:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c <= 9 || c >= 11 && c <= 33 || c >= 35 && c <= 91 || c >= 93){
                ret.state = 5;
            }
            else if(c === 34){
                ret.state = 6;
            }
            else if(c === 92){
                ret.state = 7;
            }
            else {
                ret.state = -1;
            }
            break;
        default:
            ret.state = -1;
            ret.hasArc = false;
    }
}

/*
    all the lexer data goes here.
*/
let jjlexers = [
    moveDFA0,
];

/*
    tokens that a lexical dfa state can return
*/
let jjlexTokens0 = [ 
        -1,    -1,    -1,    -1,    -1,    -1,     1,    -1,    -1,    -1,
        -1,    -1,    -1,    -1,    -1,    -1,    -1,     2,    -1,    -1,
        -1,    -1,    -1,    -1,
]; 

let jjstateCount = 11;
/*
    compressed action table: action = jjpact[jjdisact[STATE-NUM] + TOKEN]
    when action > 0, shift the token and goto state (action - 1);
    when action < 0, reduce with rule (1-action);
    when action = 0, do default action.
*/
let jjpact = [ 
        11,     9,     7,     5,     4,     3,     0,
]; 
/*
    displacement of action table.
*/
let jjdisact = [ 
         4,     4,     2,    -3,     0,    -3,    -3,     0,    -3,    -1,
        -3,
]; 
/*
    used to check if a position in jjpact is out of bouds.
    if jjcheckact[jjdisact[STATE-NUM] + TOKEN] = STATE-NUM, this position is not out of bounds.
*/
let jjcheckact = [ 
         9,     7,     4,     2,     1,     0,     0,
]; 
/*
    default action table. action = jjdefred[STATE-NUM],
    where action is the number of the rule to reduce with.
*/
let jjdefred = [ 
        -1,    -1,    -1,     0,    -1,     1,     2,    -1,     3,    -1,
         4,
]; 
/*
    compressed goto table: goto = jjpgoto[jjdisgoto[STATE-NUM] + NON_TERMINAL]
*/
let jjpgoto = [ 
         1,     9,     7,     5,    -1,    -1,
]; 
/*
    displacement of the goto table
*/
let jjdisgoto = [ 
        -1,    -5,    -5,    -5,     1,    -5,    -1,    -5,    -3,    -5,
        -5,
]; 
/*
    length of each rule: rule length = jjruleLen[RULE-NUM]
*/
let jjruleLen = [ 
         2,     3,     0,     0,     5,
]; 
/*
    index of the LHS of each rule
*/
let jjlhs = [ 
         0,     1,     3,     4,     2,
]; 
/*
    token names
*/
let jjtokenNames = [ 
                   "EOF",              "TEST",               "HKM",
    
]; 
/*
    token alias
*/
let jjtokenAlias = [ 
                  "null",              "null",               "hkm",
    
]; 


interface Token{
    id: number;
    val: string;
};

export class Parser {
    // members for lexer
    private _lexState: number[] = [];
    private _state: number = 0;
    private _matched: string[] = [];
    private _token: Token = null;
    private _marker: number = -1;
    private _backupCount: number = 0;
    private _inputBuf: string[] = [];

    // members for parser
    private _lrState: number[] = [];
    private _sematicS: any[] = [];

    private _handlers = {[s: string]: ((a1?, a2?, a3?) => any)[]} = {};

    // extra members, defined by %extra_arg
    

    /**
     *  set 
     */
    private _setImg(s: string){
        this._matched.length = 0;
        for(let i = 0;i < s.length;i++){
            this._matched.push(s.charAt(i));
        }
    }
    private _emit(name: string, a1?, a2?, a3?){
        let cbs = this._handlers[name];
        if(cbs){
            for(let cb of cbs){
                cb(a1, a2, a3);
            }
        }
    }
    on(name: string, cb: (a1?, a2?, a3?) => any){
        this._handlers[name] || (this._handlers[name] = []);
        this._handlers[name].push(cb);
    }
    private _doLexAction0(jjstaten: number){
        let jjtk = jjlexTokens0[jjstaten];
        switch(jjstaten){
            default:;
        }
        if(jjtk !== -1){
            this._token = {
                id: jjtk,
                val: this._matched.join('')
            }
            this._matched.length = 0;
        }
    }
    /**
     *  do a lexical action
     *  @api private
     *  @internal
     */
    private _doLexAction(lexstate: number, state: number){
        switch(lexstate){
            case 0:
                this._doLexAction0(state);
                break;
            default:;
        }
        this._token !== null && (this._acceptToken(this._token), (this._token = null));
    }
    private _acceptChar(c: string){
        let lexstate = this._lexState[this._lexState.length - 1];
        let retn = { state: this._state, hasArc: false, isEnd: false };
        jjlexers[lexstate](c.charCodeAt(0), retn);
        if(retn.isEnd){
            // if current state is a terminate state, be careful
            if(retn.hasArc){
                if(ret.state === -1){
                    // nowhere to go, stay where we are
                    this._doLexAction(lexstate, this._state);
                    // recover
                    this._marker = -1;
                    this._backupCount = 0;
                    this._state = 0;                    
                    // character not consumed
                    return false;
                }
                else {
                    // now we can either go to that new state, or stay where we are
                    // it is prefered to move forward, but that could lead to errors,
                    // so we need to memorize this state before move on, in case if 
                    // an error occurs later, we could just return to this state.
                    this._backupCount = 1;
                    this._marker = this._state;
                    this._state = ret.state;
                    this._matched.push(c);
                    // character consumed
                    return true;
                }
            }
            else {
                // current state doesn't lead to any state, just stay here.
                this._doLexAction(lexstate, this._state);
                // recover
                this._marker = -1;
                this._backupCount = 0;
                this._state = 0;
                // character not consumed
                return false;
            }
        }
        else {
            if(retn.state === -1){
                // nowhere to go at current state, error may have occured.
                // check marker to verify that
                if(this._marker !== -1){
                    // we have a previously marked state, which is a terminate state.
                    // rollback
                    this._state = this._marker;
                    this._marker = -1;
                    while(this._backupCount --> 0){
                        this._inputBuf.push(this._matched.pop());
                    }
                    this._doLexAction(lexstate, this._state);
                    this._state = 0;
                    // character not consumed
                    return false;
                }
                else {
                    // error occurs
                    this._emit('error', `unexpected character "${c}"`);
                }
            }
        }
    }

    private _acceptToken(t: Token){
        
    }
}