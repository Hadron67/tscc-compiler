/*
    generated by jscc, an LALR(1) parser generator made by hadroncfy.
    template for typescript, written by hadroncfy, aussi.
*/


/*
    find the next state to go in the dfa
*/
function moveDFA0(c: number, ret: { state: number, hasArc: boolean, isEnd: boolean }){
    switch(ret.state){
        case 0:
            ret.hasArc = true;
            ret.isEnd = false;
            if((c >= 9 && c <= 10) || c === 13 || c === 32){
                ret.state = 1;
            }
            else if(c === 40){
                ret.state = 2;
            }
            else if(c === 41){
                ret.state = 3;
            }
            else if(c === 42){
                ret.state = 4;
            }
            else if(c === 43){
                ret.state = 5;
            }
            else if(c === 45){
                ret.state = 6;
            }
            else if(c === 46){
                ret.state = 7;
            }
            else if(c === 47){
                ret.state = 8;
            }
            else if((c >= 48 && c <= 57)){
                ret.state = 9;
            }
            else if(c === 115){
                ret.state = 10;
            }
            else {
                ret.state = -1;
            }
            break;
        case 1:
            ret.hasArc = true;
            ret.isEnd = true;
            if((c >= 9 && c <= 10) || c === 13 || c === 32){
                ret.state = 1;
            }
            else {
                ret.state = -1;
            }
            break;
        case 2:
            ret.hasArc = false;
            ret.isEnd = true;
            ret.state = -1;
            break;
        case 3:
            ret.hasArc = false;
            ret.isEnd = true;
            ret.state = -1;
            break;
        case 4:
            ret.hasArc = false;
            ret.isEnd = true;
            ret.state = -1;
            break;
        case 5:
            ret.hasArc = false;
            ret.isEnd = true;
            ret.state = -1;
            break;
        case 6:
            ret.hasArc = false;
            ret.isEnd = true;
            ret.state = -1;
            break;
        case 7:
            ret.hasArc = true;
            ret.isEnd = false;
            if((c >= 48 && c <= 57)){
                ret.state = 11;
            }
            else {
                ret.state = -1;
            }
            break;
        case 8:
            ret.hasArc = false;
            ret.isEnd = true;
            ret.state = -1;
            break;
        case 9:
            ret.hasArc = true;
            ret.isEnd = true;
            if(c === 46){
                ret.state = 12;
            }
            else if((c >= 48 && c <= 57)){
                ret.state = 9;
            }
            else if(c === 69 || c === 101){
                ret.state = 13;
            }
            else {
                ret.state = -1;
            }
            break;
        case 10:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c === 105){
                ret.state = 14;
            }
            else {
                ret.state = -1;
            }
            break;
        case 11:
            ret.hasArc = true;
            ret.isEnd = true;
            if((c >= 48 && c <= 57)){
                ret.state = 11;
            }
            else if(c === 69 || c === 101){
                ret.state = 13;
            }
            else {
                ret.state = -1;
            }
            break;
        case 12:
            ret.hasArc = true;
            ret.isEnd = true;
            if((c >= 48 && c <= 57)){
                ret.state = 15;
            }
            else if(c === 69 || c === 101){
                ret.state = 13;
            }
            else {
                ret.state = -1;
            }
            break;
        case 13:
            ret.hasArc = true;
            ret.isEnd = false;
            if((c >= 48 && c <= 57)){
                ret.state = 16;
            }
            else {
                ret.state = -1;
            }
            break;
        case 14:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c === 110){
                ret.state = 17;
            }
            else {
                ret.state = -1;
            }
            break;
        case 15:
            ret.hasArc = true;
            ret.isEnd = true;
            if((c >= 48 && c <= 57)){
                ret.state = 15;
            }
            else if(c === 69 || c === 101){
                ret.state = 13;
            }
            else {
                ret.state = -1;
            }
            break;
        case 16:
            ret.hasArc = true;
            ret.isEnd = true;
            if((c >= 48 && c <= 57)){
                ret.state = 16;
            }
            else {
                ret.state = -1;
            }
            break;
        case 17:
            ret.hasArc = true;
            ret.isEnd = true;
            if(c === 104){
                ret.state = 18;
            }
            else {
                ret.state = -1;
            }
            break;
        case 18:
            ret.hasArc = false;
            ret.isEnd = true;
            ret.state = -1;
            break;
        default:
            ret.state = -1;
            ret.hasArc = false;
    }
}

/*
    all the lexer data goes here.
*/
let jjlexers = [
    moveDFA0,
];

/*
    tokens that a lexical dfa state can return
*/
let jjlexTokens0 = [ 
        -1,    -1,     6,     7,     4,     2,     3,    -1,     5,     1,
        -1,     1,     1,    -1,    -1,     1,     1,     8,     9,
]; 

let jjstateCount = 29;
let jjtokenCount = 10;
let jjactERR = 30;
/*
    compressed action table: action = jjpact[jjdisact[STATE-NUM] + TOKEN]
    when action > 0, shift the token and goto state (action - 1);
    when action < 0, reduce with rule (1-action);
    when action = 0, do default action.
*/
let jjpact = [ 
         4,     9,    10,    13,    12,    11,     8,     6,     7,     4,
         9,    10,     0,     0,    11,     0,     6,     7,     4,     9,
        10,     0,     0,    11,     0,     6,     7,     4,     9,    10,
         0,     0,    11,     0,     6,     7,     4,     9,    10,     0,
         0,    11,     0,     6,     7,     4,     9,    10,     0,     0,
        11,     0,     6,     7,     4,     9,    10,     0,     0,    11,
         0,     6,     7,     4,     9,    10,     0,     0,    11,     0,
         6,     7,     4,     9,    10,     0,     0,    11,     0,     6,
         7,     4,     9,    10,     0,     0,    11,     0,     6,     7,
        14,    15,    16,    17,     0,    29,    14,    15,    16,    17,
         0,    28,    14,    15,    16,    17,     0,    27,    14,    15,
        16,    17,     0,     0,     0,     0,
]; 
/*
    displacement of action table.
*/
let jjdisact = [ 
        80,     6,   106,   -10,   -10,    -2,    -3,   -10,    71,    62,
        53,    44,    35,    26,    17,     8,    -1,   -10,   -10,   100,
        94,    88,   -10,   -10,   -10,   -10,   -10,   -10,   -10,
]; 
/*
    used to check if a position in jjpact is out of bouds.
    if jjcheckact[jjdisact[STATE-NUM] + TOKEN] = STATE-NUM, this position is not out of bounds.
*/
let jjcheckact = [ 
        16,    16,    16,     6,     5,    16,     1,    16,    16,    15,
        15,    15,     0,     0,    15,     0,    15,    15,    14,    14,
        14,     0,     0,    14,     0,    14,    14,    13,    13,    13,
         0,     0,    13,     0,    13,    13,    12,    12,    12,     0,
         0,    12,     0,    12,    12,    11,    11,    11,     0,     0,
        11,     0,    11,    11,    10,    10,    10,     0,     0,    10,
         0,    10,    10,     9,     9,     9,     0,     0,     9,     0,
         9,     9,     8,     8,     8,     0,     0,     8,     0,     8,
         8,     0,     0,     0,     0,     0,     0,     0,     0,     0,
        21,    21,    21,    21,     0,    21,    20,    20,    20,    20,
         0,    20,    19,    19,    19,    19,     0,    19,     2,     2,
         2,     2,     0,     0,     0,     0,
]; 
/*
    default action table. action = jjdefred[STATE-NUM],
    where action is the number of the rule to reduce with.
*/
let jjdefred = [ 
        -1,    -1,     1,     9,    10,    -1,    -1,     0,    -1,    -1,
        -1,    -1,    -1,    -1,    -1,    -1,    -1,     6,     7,    -1,
        -1,    -1,     2,     3,     4,     5,     8,    11,    12,
]; 
/*
    compressed goto table: goto = jjpgoto[jjdisgoto[STATE-NUM] + NON_TERMINAL]
*/
let jjpgoto = [ 
        25,     4,    24,     4,    23,     4,    22,     4,    21,     4,
        20,     4,    19,     4,    18,     4,    17,     4,     1,     2,
         4,
]; 
/*
    displacement of the goto table
*/
let jjdisgoto = [ 
        17,    -4,    -4,    -4,    -4,    -4,    -4,    -4,    14,    12,
        10,     8,     6,     4,     2,     0,    -2,    -4,    -4,    -4,
        -4,    -4,    -4,    -4,    -4,    -4,    -4,    -4,    -4,
]; 
/*
    length of each rule: rule length = jjruleLen[RULE-NUM]
*/
let jjruleLen = [ 
         2,     1,     3,     3,     3,     3,     2,     2,     3,     1,
         1,     4,     4,
]; 
/*
    index of the LHS of each rule
*/
let jjlhs = [ 
         0,     1,     2,     2,     2,     2,     2,     2,     2,     2,
         2,     3,     3,
]; 
/*
    token names
*/
let jjtokenNames = [ 
                   "EOF",               "NUM",              "PLUS",
                 "MINUS",             "TIMES",            "DIVIDE",
                   "BRA",               "KET",               "SIN",
                  "SINH",
]; 
/*
    token alias
*/
let jjtokenAlias = [ 
                    null,                null,                 "+",
                     "-",                 "*",                 "/",
                     "(",                 ")",               "sin",
                  "sinh",
]; 


export function tokenToString(tk: number){
    return jjtokenAlias[tk] === null ? `<${jjtokenNames[tk]}>` : `"${jjtokenAlias[tk]}"`;
}

export class Token {
    constructor(
        public id: number,
        public val: string,
        public startLine: number,
        public startColumn: number,
        public endLine: number,
        public endColumn: number
    ){}
    toString(){
        return (jjtokenAlias[this.id] === null ? 
            `<${jjtokenNames[this.id]}>` :
            `"${jjtokenAlias[this.id]}"`) + `("${this.val}")`;
    }
}
export class Parser {
    // members for lexer
    private _lexState: number[];
    private _state: number;
    private _matched: string;
    private _token: Token;
    
    private _marker: { state: number, line: number, column: number } = { state: -1, line: 0, column: 0 };
    private _backupCount: number;

    private _line: number;
    private _column: number;
    private _tline: number;
    private _tcolumn: number;

    // members for parser
    private _lrState: number[] = [];
    private _sematicS: number[] = [];
    private _sematicVal: number;

    private _stop;

    private _handlers: {[s: string]: ((a1?, a2?, a3?) => any)[]} = {};

    // extra members, defined by %extra_arg
    
    val: number;


    constructor(){
        this.init();
    }
    init(){
        this._lexState = [ 0 ];// DEFAULT
        this._state = 0;
        this._matched = '';
        this._token = null;
        this._marker.state = -1;
        this._backupCount = 0;
        this._line = this._tline = 1;
        this._column = this._tcolumn = 1;
        
        this._lrState = [ 0 ];
        this._sematicS = [];
        this._sematicVal = null;

        this._stop = false;
    }
    /**
     *  set 
     */
    private _setImg(s: string){
        this._matched = s;
        this._tline = this._line;
        this._tcolumn = this._column;
    }
    private _prepareToken(tid: number){
        this._token = new Token(
            tid,
            this._matched,
            this._tline,
            this._tcolumn,
            this._line,
            this._column
        );
        this._matched = '';
        this._tline = this._line;
        this._tcolumn = this._column;
    }
    private _returnToken(){
        this._emit('token', jjtokenNames[this._token.id], this._token.val);
        while(!this._stop && !this._acceptToken(this._token));
        this._token = null;
    }
    private _emit(name: string, a1?, a2?, a3?){
        let cbs = this._handlers[name];
        if(cbs){
            for(let cb of cbs){
                cb(a1, a2, a3);
            }
        }
    }
    on(name: string, cb: (a1?, a2?, a3?) => any){
        this._handlers[name] || (this._handlers[name] = []);
        this._handlers[name].push(cb);
    }
    private _doLexAction0(jjstaten: number){
        let jjtk = jjlexTokens0[jjstaten];
        jjtk !== -1 && this._prepareToken(jjtk);
        switch(jjstaten){
            case 1:
                this._setImg("");
                break;
            case 9:
                 this._sematicVal = Number(this._token.val); 
                break;
            case 11:
                 this._sematicVal = Number(this._token.val); 
                break;
            case 12:
                 this._sematicVal = Number(this._token.val); 
                break;
            case 15:
                 this._sematicVal = Number(this._token.val); 
                break;
            case 16:
                 this._sematicVal = Number(this._token.val); 
                break;
            default:;
        }
    }
    /**
     *  do a lexical action
     *  @api private
     *  @internal
     */
    private _doLexAction(lexstate: number, state: number){
        switch(lexstate){
            case 0:
                this._doLexAction0(state);
                break;
            default:;
        }
        this._token !== null && this._returnToken();
    }
    private _rollback(){
        let ret = this._matched.substr(this._matched.length - this._backupCount, this._backupCount);
        this._matched = this._matched.substr(0, this._matched.length - this._backupCount);
        this._backupCount = 0;
        this._line = this._marker.line;
        this._column = this._marker.column;
        this._state = this._marker.state;
        this._marker.state = -1;
        return ret;
    }
    private _mark(){
        this._marker.state = this._state;
        this._marker.line = this._line;
        this._marker.column = this._column;
        this._backupCount = 0;
    }
    /**
     *  accept a character
     *  @return - true if the character is consumed, false if not consumed
     *  @api private
     *  @internal
     */
    private _acceptChar(c: string){
        function consume(cela: Parser, c: string){
            c === '\n' ? (cela._line++, cela._column = 0) : (cela._column++);
            cela._matched += c;
            cela._marker.state !== -1 && (cela._backupCount++);
            return true;
        }
        let lexstate = this._lexState[this._lexState.length - 1];
        let retn = { state: this._state, hasArc: false, isEnd: false };
        jjlexers[lexstate](c.charCodeAt(0), retn);
        if(retn.isEnd){
            // if current state is a terminate state, be careful
            if(retn.hasArc){
                if(retn.state === -1){
                    // nowhere to go, stay where we are
                    this._doLexAction(lexstate, this._state);
                    // recover
                    this._marker.state = -1;
                    this._backupCount = 0;
                    this._state = 0;                    
                    // character not consumed
                    return false;
                }
                else {
                    // now we can either go to that new state, or stay where we are
                    // it is prefered to move forward, but that could lead to errors,
                    // so we need to memorize this state before move on, in case if 
                    // an error occurs later, we could just return to this state.
                    this._mark();
                    this._state = retn.state;
                    return consume(this, c);
                }
            }
            else {
                // current state doesn't lead to any state, just stay here.
                this._doLexAction(lexstate, this._state);
                // recover
                this._marker.state = -1;
                this._backupCount = 0;
                this._state = 0;
                // character not consumed
                return false;
            }
        }
        else {
            if(retn.state === -1){
                // nowhere to go at current state, error may have occured.
                // check marker to verify that
                if(this._marker.state !== -1){
                    // we have a previously marked state, which is a terminate state.
                    let s = this._rollback();
                    this._doLexAction(lexstate, this._state);
                    this._state = 0;
                    this.accept(s);
                    // character not consumed
                    return false;
                }
                else {
                    // error occurs
                    this._emit('lexicalerror', `unexpected character "${c}"`, this._line, this._column);
                    // force consume
                    return true;
                }
            }
            else {
                this._state = retn.state;
                // character consumed
                return consume(this, c);
            }
        }
    }
    private _acceptEOF(){
        if(this._state === 0){
            // recover
            this._prepareToken(0);
            this._returnToken();
            return true;
        }
        else {
            let lexstate = this._lexState[this._lexState.length - 1];
            let retn = { state: this._state, hasArc: false, isEnd: false };
            jjlexers[lexstate](-1, retn);
            if(retn.isEnd){
                this._doLexAction(lexstate, this._state);
                this._state = 0;
                this._marker.state = -1;
                return false;
            }
            else if(this._marker.state !== -1){
                let s = this._rollback();
                this._doLexAction(lexstate, this._state);
                this._state = 0;
                this.accept(s);
                return false;
            }
            else {
                this._emit('lexicalerror', 'unexpected end of file');
                return true;
            }
        }
    }
    /**
     *  input a string
     *  @api public
     */
    accept(s: string){
        for(let i = 0; i < s.length && !this._stop;){
            this._acceptChar(s.charAt(i)) && i++;
        }
    }
    /**
     *  tell the compiler that end of file is reached
     *  @api public
     */
    end(){
        while(!this._stop && !this._acceptEOF());
        this._stop = true;
    }
    halt(){
        this._stop = true;
    }
    private _doReduction(jjrulenum: number){
        let jjnt = jjlhs[jjrulenum];
        let jjsp = this._sematicS.length;
        let jjtop = this._sematicS[jjsp - jjruleLen[jjrulenum]] || null;
        switch(jjrulenum){
            case 1:
                /* 1: start => expr */
                var a = this._sematicS[jjsp - 1];
                { this.val = a; }
                break;
            case 2:
                /* 2: expr => expr "+" expr */
                var a = this._sematicS[jjsp - 3];
                var b = this._sematicS[jjsp - 1];
                { jjtop = a + b; }
                break;
            case 3:
                /* 3: expr => expr "-" expr */
                var a = this._sematicS[jjsp - 3];
                var b = this._sematicS[jjsp - 1];
                { jjtop = a - b; }
                break;
            case 4:
                /* 4: expr => expr "*" expr */
                var a = this._sematicS[jjsp - 3];
                var b = this._sematicS[jjsp - 1];
                { jjtop = a * b; }
                break;
            case 5:
                /* 5: expr => expr "/" expr */
                var a = this._sematicS[jjsp - 3];
                var b = this._sematicS[jjsp - 1];
                { jjtop = a / b; }
                break;
            case 6:
                /* 6: expr => "+" expr */
                var a = this._sematicS[jjsp - 1];
                { jjtop = a; }
                break;
            case 7:
                /* 7: expr => "-" expr */
                var a = this._sematicS[jjsp - 1];
                { jjtop = -a; }
                break;
            case 8:
                /* 8: expr => "(" expr ")" */
                var a = this._sematicS[jjsp - 2];
                { jjtop = a; }
                break;
            case 11:
                /* 11: funcs => "sin" "(" expr ")" */
                var a = this._sematicS[jjsp - 2];
                { jjtop = Math.sin(a); }
                break;
            case 12:
                /* 12: funcs => "sinh" "(" expr ")" */
                var a = this._sematicS[jjsp - 2];
                { jjtop = (Math as any).sinh(a); }
                break;
        }
        this._lrState.length -= jjruleLen[jjrulenum];
        let jjcstate = this._lrState[this._lrState.length - 1];
        this._lrState.push(jjpgoto[jjdisgoto[jjcstate] + jjnt]);

        this._sematicS.length -= jjruleLen[jjrulenum];
        this._sematicS.push(jjtop);
    }

    private _acceptToken(t: Token){
        // look up action table
        let cstate = this._lrState[this._lrState.length - 1];
        let ind = jjdisact[cstate] + t.id;
        let act = 0;
        if(ind < 0 || ind >= jjpact.length || jjcheckact[ind] !== cstate){
            act = -jjdefred[cstate] - 1;
        }
        else {
            act = jjpact[ind];
        }
        if(act === jjactERR){
            // explicit error
            this._syntaxError(t);
            return true;
        }
        else if(act > 0){
            // shift
            if(t.id === 0){
                // end of file
                this._stop = true;
                this._emit('accept');
                return true;
            }
            else {
                this._lrState.push(act - 1);
                this._sematicS.push(this._sematicVal);
                this._sematicVal = null;
                // token consumed
                return true;
            }
        }
        else if(act < 0){
            this._doReduction(-act - 1);
            return false;
        }
        else {
            // error
            this._syntaxError(t);
            // force consume
            return true;
        }
    }
    private _syntaxError(t: Token){
        let msg = `unexpected token ${t.toString()}, expecting one of the following token(s):\n`
        msg += this._expected(this._lrState[this._lrState.length - 1]);
        this._emit("syntaxerror", msg, t);
    }
    private _expected(state: number){
        let dis = jjdisact[state];
        let ret = '';
        function expect(tk: number){
            let ind = dis + tk;
            if(ind < 0 || ind >= jjpact.length || state !== jjcheckact[ind]){
                return jjdefred[state] !== -1;
            }
            else {
                return true;
            }
        }
        for(let tk = 0; tk < jjtokenCount; tk++){
            expect(tk) && (ret += `    ${tokenToString(tk)} ...` + '\n');
        }
        return ret;
    }
}