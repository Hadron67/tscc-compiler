/*
    generated by jscc, an LALR(1) parser generator made by hadroncfy.
    template for typescript, written by hadroncfy, aussi.
*/

'use strict';
var Mathx = {};
function Quaternion(a, b, c, d){
    // this = a + bi + cj + dk
    this.a = a;
    this.b = b || 0;
    this.c = c || 0;
    this.d = d || 0;
}
Quaternion.prototype.toString = function(){
    return [this.a, this.b + 'i', this.c + 'j', this.d + 'k'].join(' + ');
}
Quaternion.prototype.neg = function(){
    return new Quaternion(-this.a, -this.b, -this.c, -this.d);
}
Quaternion.prototype.dagger = function(){
    return new Quaternion(this.a, -this.b, -this.c, -this.d);
}
Quaternion.prototype.inv = function(){
    var m2 = this.module2().a;
    return new Quaternion(this.a / m2, -this.b / m2, -this.c / m2, -this.d / m2);
}
Quaternion.prototype.module2 = function(){
    return new Quaternion(this.a * this.a + this.b * this.b + this.c * this.c + this.d * this.d);
}
Quaternion.prototype.module = function(){
    return new Quaternion(Math.sqrt(this.module2().a));
}
Mathx.Quaternion = Quaternion;

Quaternion.addQ = function(x, y){
    return new Quaternion(x.a + y.a, x.b + y.b, x.c + y.c, x.d + y.d);
}
Quaternion.minusQ = function(x, y){
    return new Quaternion(x.a - y.a, x.b - y.b, x.c - y.c, x.d - y.d);
}
Quaternion.multiQ = function(x, y){
    return new Quaternion(
        x.a * y.a - x.b * y.b - x.c * y.c - x.d * y.d,
        x.a * y.b + x.b * y.a + x.c * y.d - x.d * y.c,
        x.a * y.c - x.b * y.d + x.c * y.a + x.d * y.b,
        x.a * y.d + x.b * y.c - x.c * y.b + x.d * y.a
    );
}
Quaternion.exp = function(x){
    var fc = Math.exp(x.a);
    var mod2 = Math.sqrt(x.b * x.b + x.c * x.c + x.d * x.d);
    return new Quaternion(
        fc * Math.cos(mod2),
        fc * x.b * Math.sin(mod2) / mod2,
        fc * x.c * Math.sin(mod2) / mod2,
        fc * x.d * Math.sin(mod2) / mod2
    );
}

function cut(s){
    return s.substr(0, s.length - 1);
}

/*
    find the next state to go in the dfa
*/
function moveDFA0(c, ret){
    switch(ret.state){
        case 0:
            ret.hasArc = true;
            ret.isEnd = false;
            if((c >= 9 && c <= 10) || c === 13 || c === 32){
                ret.state = 1;
            }
            else if(c === 40){
                ret.state = 2;
            }
            else if(c === 41){
                ret.state = 3;
            }
            else if(c === 42){
                ret.state = 4;
            }
            else if(c === 43){
                ret.state = 5;
            }
            else if(c === 45){
                ret.state = 6;
            }
            else if(c === 46){
                ret.state = 7;
            }
            else if(c === 47){
                ret.state = 8;
            }
            else if((c >= 48 && c <= 57)){
                ret.state = 9;
            }
            else if(c === 101){
                ret.state = 10;
            }
            else if(c === 124){
                ret.state = 11;
            }
            else {
                ret.state = -1;
            } 
            break;
        case 1:
            ret.hasArc = true;
            ret.isEnd = true;
            if((c >= 9 && c <= 10) || c === 13 || c === 32){
                ret.state = 1;
            }
            else {
                ret.state = -1;
            } 
            break;
        case 2:
            ret.hasArc = false;
            ret.isEnd = true;
            ret.state = -1;
            break;
        case 3:
            ret.hasArc = false;
            ret.isEnd = true;
            ret.state = -1;
            break;
        case 4:
            ret.hasArc = false;
            ret.isEnd = true;
            ret.state = -1;
            break;
        case 5:
            ret.hasArc = false;
            ret.isEnd = true;
            ret.state = -1;
            break;
        case 6:
            ret.hasArc = false;
            ret.isEnd = true;
            ret.state = -1;
            break;
        case 7:
            ret.hasArc = true;
            ret.isEnd = false;
            if((c >= 48 && c <= 57)){
                ret.state = 12;
            }
            else {
                ret.state = -1;
            } 
            break;
        case 8:
            ret.hasArc = false;
            ret.isEnd = true;
            ret.state = -1;
            break;
        case 9:
            ret.hasArc = true;
            ret.isEnd = true;
            if(c === 46){
                ret.state = 13;
            }
            else if((c >= 48 && c <= 57)){
                ret.state = 9;
            }
            else if(c === 69 || c === 101){
                ret.state = 14;
            }
            else if(c === 73 || c === 105){
                ret.state = 15;
            }
            else if(c === 74 || c === 106){
                ret.state = 16;
            }
            else if(c === 75 || c === 107){
                ret.state = 17;
            }
            else {
                ret.state = -1;
            } 
            break;
        case 10:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c === 120){
                ret.state = 18;
            }
            else {
                ret.state = -1;
            } 
            break;
        case 11:
            ret.hasArc = false;
            ret.isEnd = true;
            ret.state = -1;
            break;
        case 12:
            ret.hasArc = true;
            ret.isEnd = true;
            if((c >= 48 && c <= 57)){
                ret.state = 12;
            }
            else if(c === 69 || c === 101){
                ret.state = 14;
            }
            else if(c === 73 || c === 105){
                ret.state = 15;
            }
            else if(c === 74 || c === 106){
                ret.state = 16;
            }
            else if(c === 75 || c === 107){
                ret.state = 17;
            }
            else {
                ret.state = -1;
            } 
            break;
        case 13:
            ret.hasArc = true;
            ret.isEnd = true;
            if((c >= 48 && c <= 57)){
                ret.state = 19;
            }
            else if(c === 69 || c === 101){
                ret.state = 14;
            }
            else if(c === 73 || c === 105){
                ret.state = 15;
            }
            else if(c === 74 || c === 106){
                ret.state = 16;
            }
            else if(c === 75 || c === 107){
                ret.state = 17;
            }
            else {
                ret.state = -1;
            } 
            break;
        case 14:
            ret.hasArc = true;
            ret.isEnd = false;
            if((c >= 48 && c <= 57)){
                ret.state = 20;
            }
            else {
                ret.state = -1;
            } 
            break;
        case 15:
            ret.hasArc = false;
            ret.isEnd = true;
            ret.state = -1;
            break;
        case 16:
            ret.hasArc = false;
            ret.isEnd = true;
            ret.state = -1;
            break;
        case 17:
            ret.hasArc = false;
            ret.isEnd = true;
            ret.state = -1;
            break;
        case 18:
            ret.hasArc = true;
            ret.isEnd = false;
            if(c === 112){
                ret.state = 21;
            }
            else {
                ret.state = -1;
            } 
            break;
        case 19:
            ret.hasArc = true;
            ret.isEnd = true;
            if((c >= 48 && c <= 57)){
                ret.state = 19;
            }
            else if(c === 69 || c === 101){
                ret.state = 14;
            }
            else if(c === 73 || c === 105){
                ret.state = 15;
            }
            else if(c === 74 || c === 106){
                ret.state = 16;
            }
            else if(c === 75 || c === 107){
                ret.state = 17;
            }
            else {
                ret.state = -1;
            } 
            break;
        case 20:
            ret.hasArc = true;
            ret.isEnd = true;
            if((c >= 48 && c <= 57)){
                ret.state = 20;
            }
            else if(c === 73 || c === 105){
                ret.state = 15;
            }
            else if(c === 74 || c === 106){
                ret.state = 16;
            }
            else if(c === 75 || c === 107){
                ret.state = 17;
            }
            else {
                ret.state = -1;
            } 
            break;
        case 21:
            ret.hasArc = false;
            ret.isEnd = true;
            ret.state = -1;
            break;
        default:
            ret.state = -1;
            ret.hasArc = false;
    }
}

/*
    all the lexer data goes here.
*/
var jjlexers = [
    moveDFA0,
];

/*
    tokens that a lexical dfa state can return
*/
var jjlexTokens0 = [ 
        -1,    -1,    10,    11,     7,     5,     6,    -1,     8,     1,
        -1,     9,     1,     1,    -1,     2,     3,     4,    -1,     1,
         1,    12,
]; 

var jjstateCount = 31;
var jjtokenCount = 13;
var jjactERR = 32;
/*
    compressed action table: action = jjpact[jjdisact[STATE-NUM] + TOKEN]
    when action > 0, shift the token and goto state (action - 1);
    when action < 0, reduce with rule (1-action);
    when action = 0, do default action.
*/
var jjpact = [ 
         4,     5,     6,     7,    11,    12,    18,    19,    14,    13,
        15,     9,     4,     5,     6,     7,    11,    12,    18,    19,
        14,    13,    10,     9,     4,     5,     6,     7,    11,    12,
         0,     0,    14,    13,     0,     9,     4,     5,     6,     7,
        11,    12,     0,     0,    14,    13,     0,     9,     4,     5,
         6,     7,    11,    12,     0,     0,    14,    13,     0,     9,
         4,     5,     6,     7,    11,    12,     0,     0,    14,    13,
         0,     9,     4,     5,     6,     7,    11,    12,     0,     0,
        14,    13,     0,     9,     4,     5,     6,     7,    11,    12,
         0,     0,    14,    13,     0,     9,     4,     5,     6,     7,
        11,    12,     0,     0,    14,    13,     0,     9,     4,     5,
         6,     7,    16,    17,    18,    19,    14,    13,    31,     9,
        16,    17,    18,    19,    30,    16,    17,    18,    19,     0,
         0,    29,    16,    17,    18,    19,     0,     0,     0,     0,
    
]; 
/*
    displacement of action table.
*/
var jjdisact = [ 
        95,    22,   127,   -13,   -13,   -13,   -13,   -13,     0,   -13,
        83,    71,    59,    47,    35,    23,    11,   107,    -1,   -13,
       -13,   120,   115,   107,    11,    -1,   -13,   -13,   -13,   -13,
       -13,
]; 
/*
    used to check if a position in jjpact is out of bouds.
    if jjcheckact[jjdisact[STATE-NUM] + TOKEN] = STATE-NUM, this position is not out of bounds.
*/
var jjcheckact = [ 
        18,    18,    18,    18,    18,    18,    25,    25,    18,    18,
         8,    18,    16,    16,    16,    16,    16,    16,    24,    24,
        16,    16,     1,    16,    15,    15,    15,    15,    15,    15,
         0,     0,    15,    15,     0,    15,    14,    14,    14,    14,
        14,    14,     0,     0,    14,    14,     0,    14,    13,    13,
        13,    13,    13,    13,     0,     0,    13,    13,     0,    13,
        12,    12,    12,    12,    12,    12,     0,     0,    12,    12,
         0,    12,    11,    11,    11,    11,    11,    11,     0,     0,
        11,    11,     0,    11,    10,    10,    10,    10,    10,    10,
         0,     0,    10,    10,     0,    10,     0,     0,     0,     0,
         0,     0,     0,     0,     0,     0,     0,     0,    17,    17,
        17,    17,    23,    23,    23,    23,    17,    17,    23,    17,
        22,    22,    22,    22,    22,    21,    21,    21,    21,     0,
         0,    21,     2,     2,     2,     2,     0,     0,     0,     0,
    
]; 
/*
    default action table. action = jjdefred[STATE-NUM],
    where action is the number of the rule to reduce with.
*/
var jjdefred = [ 
        -1,    -1,     1,    11,    12,    13,    14,    15,    -1,     0,
        -1,    -1,    -1,    -1,    -1,    -1,    -1,     8,    -1,     6,
         7,    -1,    -1,    -1,     2,     3,     4,     5,     9,    10,
        16,
]; 
/*
    compressed goto table: goto = jjpgoto[jjdisgoto[STATE-NUM] + NON_TERMINAL]
*/
var jjpgoto = [ 
        27,     7,    26,     7,    25,     7,    24,     7,    23,     7,
        22,     7,    21,     7,    20,     7,    19,     7,     1,     2,
         7,
]; 
/*
    displacement of the goto table
*/
var jjdisgoto = [ 
        17,    -4,    -4,    -4,    -4,    -4,    -4,    -4,    -4,    -4,
        14,    12,    10,     8,     6,     4,     2,     0,    -2,    -4,
        -4,    -4,    -4,    -4,    -4,    -4,    -4,    -4,    -4,    -4,
        -4,
]; 
/*
    length of each rule: rule length = jjruleLen[RULE-NUM]
*/
var jjruleLen = [ 
         2,     1,     3,     3,     3,     3,     2,     2,     2,     3,
         3,     1,     1,     1,     1,     1,     4,
]; 
/*
    index of the LHS of each rule
*/
var jjlhs = [ 
         0,     1,     2,     2,     2,     2,     2,     2,     2,     2,
         2,     2,     2,     2,     2,     2,     3,
]; 
/*
    token names
*/
var jjtokenNames = [ 
                   "EOF",             "CONST",                 "I",
                     "J",                 "K",              "PLUS",
                 "MINUS",             "TIMES",            "DIVIDE",
                   "ABS",               "BRA",               "KET",
                   "EXP",
]; 
/*
    token alias
*/
var jjtokenAlias = [ 
                    null,                null,                null,
                    null,                null,                 "+",
                     "-",                 "*",                 "/",
                     "|",                 "(",                 ")",
                   "exp",
]; 


function tokenToString(tk){
    return jjtokenAlias[tk] === null ? "<" + jjtokenNames[tk] + ">" : '"' + jjtokenAlias[tk] + '"';
}
function Token(id, val, startLine, startColumn, endLine, endColumn){
    this.id = id;
    this.val = val;
    this.startLine = startLine;
    this.startColumn = startColumn;
    this.endLine = endLine;
    this.endColumn = endColumn;
}
Token.prototype.clone = function(){
    return new Token(
        this.id,
        this.val,
        this.startLine,
        this.startColumn,
        this.endLine,
        this.endColumn
    );
}
Token.prototype.toString = function(){
    return (jjtokenAlias[this.id] === null ? 
        '<' + jjtokenNames[this.id] + '>' :
        '"' + jjtokenAlias[this.id] + '"') + "(" + this.val + ")";
}
function createParser() {
    // members for lexer
    var _lexState;
    var _state;
    var _matched;
    var _token;
    
    var _marker = { state: -1, line: 0, column: 0 };
    var _backupCount;

    var _line;
    var _column;
    var _tline;
    var _tcolumn;

    // members for parser
    var _lrState;
    var _sematicS = [];
    var _sematicVal;

    var _stop;

    var _handlers = {};

    // extra members, defined by %extra_arg
    
    var out;


    return {
        init: init,
        on: on,
        accept: accept,
        end: end,
        halt: halt
    };
    function init(out1){
        _lexState = [ 0 ];// DEFAULT
        _state = 0;
        _matched = '';
        _token = new Token(-1, null, 0, 0, 0, 0);
        _marker.state = -1;
        _backupCount = 0;
        _line = _tline = 0;
        _column = _tcolumn = 0;
        
        _lrState = [ 0 ];
        _sematicS = [];
        _sematicVal = null;

        _stop = false;
        
    out = out1;

    }
    /**
     *  set 
     */
    function _setImg(s){
        _matched = s;
        _tline = _line;
        _tcolumn = _column;
    }
    function _prepareToken(tid){
        _token.id = tid;
        _token.val = _matched;
        _token.startLine = _tline;
        _token.startColumn = _tcolumn;
        _token.endLine = _line;
        _token.endColumn = _column - 1;

        _matched = '';
        _tline = _line;
        _tcolumn = _column;
    }
    function _returnToken(){
        _emit('token', jjtokenNames[_token.id], _token.val);
        while(!_stop && !_acceptToken(_token));
        _token.id = -1;
    }
    function _emit(name, a1, a2, a3){
        var cbs = _handlers[name];
        if(cbs){
            for(var i = 0; i < cbs.length; i++){
                cbs[i](a1, a2, a3);
            }
        }
    }
    function on(name, cb){
        _handlers[name] || (_handlers[name] = []);
        _handlers[name].push(cb);
    }
    function _doLexAction0(jjstaten){
        let jjtk = jjlexTokens0[jjstaten];
        jjtk !== -1 && _prepareToken(jjtk);
        switch(jjstaten){
            case 1:
                _setImg("");
                break;
            case 9:
                 _sematicVal = new Quaternion(Number(_token.val), 0, 0, 0); 
                break;
            case 12:
                 _sematicVal = new Quaternion(Number(_token.val), 0, 0, 0); 
                break;
            case 13:
                 _sematicVal = new Quaternion(Number(_token.val), 0, 0, 0); 
                break;
            case 15:
                 _sematicVal = new Quaternion(0, Number(cut(_token.val)), 0, 0); 
                break;
            case 16:
                 _sematicVal = new Quaternion(0, 0, Number(cut(_token.val)), 0); 
                break;
            case 17:
                 _sematicVal = new Quaternion(0, 0, 0, Number(cut(_token.val))); 
                break;
            case 19:
                 _sematicVal = new Quaternion(Number(_token.val), 0, 0, 0); 
                break;
            case 20:
                 _sematicVal = new Quaternion(Number(_token.val), 0, 0, 0); 
                break;
            default:;
        }
    }
    /**
     *  do a lexical action
     *  @api private
     *  @internal
     */
    function _doLexAction(lexstate, state){
        switch(lexstate){
            case 0:
                _doLexAction0(state);
                break;
            default:;
        }
        _token.id !== -1 && _returnToken();
    }
    function _rollback(){
        let ret = _matched.substr(_matched.length - _backupCount, _backupCount);
        _matched = _matched.substr(0, _matched.length - _backupCount);
        _backupCount = 0;
        _line = _marker.line;
        _column = _marker.column;
        _state = _marker.state;
        _marker.state = -1;
        return ret;
    }
    function _mark(){
        _marker.state = _state;
        _marker.line = _line;
        _marker.column = _column;
        _backupCount = 0;
    }
    function _consume(c){
        c === '\n' ? (_line++, _column = 0) : (_column += c.charCodeAt(0) > 0xff ? 2 : 1);
        _matched += c;
        _marker.state !== -1 && (_backupCount++);
        return true;
    }
    /**
     *  accept a character
     *  @return - true if the character is consumed, false if not consumed
     *  @api private
     *  @internal
     */
    function _acceptChar(c){
        var lexstate = _lexState[_lexState.length - 1];
        var retn = { state: _state, hasArc: false, isEnd: false };
        jjlexers[lexstate](c.charCodeAt(0), retn);
        if(retn.isEnd){
            // if current state is a terminate state, be careful
            if(retn.hasArc){
                if(retn.state === -1){
                    // nowhere to go, stay where we are
                    _doLexAction(lexstate, _state);
                    // recover
                    _marker.state = -1;
                    _backupCount = 0;
                    _state = 0;                    
                    // character not consumed
                    return false;
                }
                else {
                    // now we can either go to that new state, or stay where we are
                    // it is prefered to move forward, but that could lead to errors,
                    // so we need to memorize this state before move on, in case if 
                    // an error occurs later, we could just return to this state.
                    _mark();
                    _state = retn.state;
                    return _consume(c);
                }
            }
            else {
                // current state doesn't lead to any state, just stay here.
                _doLexAction(lexstate, _state);
                // recover
                _marker.state = -1;
                _backupCount = 0;
                _state = 0;
                // character not consumed
                return false;
            }
        }
        else {
            if(retn.state === -1){
                // nowhere to go at current state, error may have occured.
                // check marker to verify that
                if(_marker.state !== -1){
                    // we have a previously marked state, which is a terminate state.
                    var s = _rollback();
                    _doLexAction(lexstate, _state);
                    _state = 0;
                    accept(s);
                    // character not consumed
                    return false;
                }
                else {
                    // error occurs
                    _emit('lexicalerror', "unexpected character " + c, _line, _column);
                    // force consume
                    return true;
                }
            }
            else {
                _state = retn.state;
                // character consumed
                return _consume(c);
            }
        }
    }
    function _acceptEOF(){
        if(_state === 0){
            // recover
            _prepareToken(0);
            _returnToken();
            return true;
        }
        else {
            let lexstate = _lexState[_lexState.length - 1];
            let retn = { state: _state, hasArc: false, isEnd: false };
            jjlexers[lexstate](-1, retn);
            if(retn.isEnd){
                _doLexAction(lexstate, _state);
                _state = 0;
                _marker.state = -1;
                return false;
            }
            else if(_marker.state !== -1){
                let s = _rollback();
                _doLexAction(lexstate, _state);
                _state = 0;
                accept(s);
                return false;
            }
            else {
                _emit('lexicalerror', 'unexpected end of file');
                return true;
            }
        }
    }
    /**
     *  input a string
     *  @api public
     */
    function accept(s){
        for(let i = 0; i < s.length && !_stop;){
            _acceptChar(s.charAt(i)) && i++;
        }
    }
    /**
     *  tell the compiler that end of file is reached
     *  @api public
     */
    function end(){
        while(!_stop && !_acceptEOF());
        _stop = true;
    }
    function halt(){
        _stop = true;
    }
    function _doReduction(jjrulenum){
        var jjnt = jjlhs[jjrulenum];
        var jjsp = _sematicS.length;
        var jjtop = _sematicS[jjsp - jjruleLen[jjrulenum]] || null;
        switch(jjrulenum){
            case 1:
                /* 1: start => expr */
                var a = _sematicS[jjsp - 1];
                { out.val = a; }
                break;
            case 2:
                /* 2: expr => expr "+" expr */
                var a = _sematicS[jjsp - 3];
                var b = _sematicS[jjsp - 1];
                { jjtop = Quaternion.addQ(a, b); }
                break;
            case 3:
                /* 3: expr => expr "-" expr */
                var a = _sematicS[jjsp - 3];
                var b = _sematicS[jjsp - 1];
                { jjtop = Quaternion.minusQ(a, b); }
                break;
            case 4:
                /* 4: expr => expr "*" expr */
                var a = _sematicS[jjsp - 3];
                var b = _sematicS[jjsp - 1];
                { jjtop = Quaternion.multiQ(a, b); }
                break;
            case 5:
                /* 5: expr => expr "/" expr */
                var a = _sematicS[jjsp - 3];
                var b = _sematicS[jjsp - 1];
                { jjtop = Quaternion.multiQ(a, b.inv()) }
                break;
            case 6:
                /* 6: expr => "+" expr */
                var a = _sematicS[jjsp - 1];
                { jjtop = a; }
                break;
            case 7:
                /* 7: expr => "-" expr */
                var a = _sematicS[jjsp - 1];
                { jjtop = a.neg(); }
                break;
            case 8:
                /* 8: expr => expr "*" */
                var a = _sematicS[jjsp - 2];
                { jjtop = a.dagger(); }
                break;
            case 9:
                /* 9: expr => "(" expr ")" */
                var a = _sematicS[jjsp - 2];
                { jjtop = a; }
                break;
            case 10:
                /* 10: expr => "|" expr "|" */
                var a = _sematicS[jjsp - 2];
                { jjtop = a.module(); }
                break;
            case 16:
                /* 16: funcs => "exp" "(" expr ")" */
                var a = _sematicS[jjsp - 2];
                { jjtop = Quaternion.exp(a); }
                break;
        }
        _lrState.length -= jjruleLen[jjrulenum];
        var jjcstate = _lrState[_lrState.length - 1];
        _lrState.push(jjpgoto[jjdisgoto[jjcstate] + jjnt]);

        _sematicS.length -= jjruleLen[jjrulenum];
        _sematicS.push(jjtop);
    }

    function _acceptToken(t){
        // look up action table
        var cstate = _lrState[_lrState.length - 1];
        var ind = jjdisact[cstate] + t.id;
        var act = 0;
        if(ind < 0 || ind >= jjpact.length || jjcheckact[ind] !== cstate){
            act = -jjdefred[cstate] - 1;
        }
        else {
            act = jjpact[ind];
        }
        if(act === jjactERR){
            // explicit error
            _syntaxError(t);
            return true;
        }
        else if(act > 0){
            // shift
            if(t.id === 0){
                // end of file
                _stop = true;
                _emit('accept');
                return true;
            }
            else {
                _lrState.push(act - 1);
                _sematicS.push(_sematicVal);
                _sematicVal = null;
                // token consumed
                return true;
            }
        }
        else if(act < 0){
            _doReduction(-act - 1);
            return false;
        }
        else {
            // error
            _syntaxError(t);
            // force consume
            return true;
        }
    }
    function _syntaxError(t){
        var msg = "unexpected token " + t.toString() + ", expecting one of the following token(s):\n"
        msg += _expected(_lrState[_lrState.length - 1]);
        _emit("syntaxerror", msg, t);
    }
    function _expected(state){
        var dis = jjdisact[state];
        var ret = '';
        function expect(tk){
            var ind = dis + tk;
            if(ind < 0 || ind >= jjpact.length || state !== jjcheckact[ind]){
                return jjdefred[state] !== -1;
            }
            else {
                return true;
            }
        }
        for(var tk = 0; tk < jjtokenCount; tk++){
            expect(tk) && (ret += "    " + tokenToString(tk) + " ..." + '\n');
        }
        return ret;
    }
}


module.exports = function (s, args){
    var parser = createParser();
    var out = { val: null };
    var errMsg = null;
    parser.init(out);
    parser.on('lexicalerror', function(msg, line, column){
        errMsg = (msg + ' at line ' + (line + 1) + ' column ' + (column + 1));
        parser.halt();
    });
    parser.on('syntaxerror', function(msg, token){
        errMsg = ('syntax error: line ' + (token.startLine + 1) + ' column ' + (token.startColumn + 1) + ': ' + msg);
        parser.halt();
    });
    parser.on('accept', function(){
        // console.log('result: ' + out.val);
    });
    parser.accept(s);
    parser.end();
    if(errMsg !== null){
        throw errMsg;
    }
    return out.val.toString();
};