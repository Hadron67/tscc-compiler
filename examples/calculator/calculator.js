/*
    generated by jscc, an LALR(1) parser generator made by hadroncfy.
    template for typescript, written by hadroncfy, aussi.
*/
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    exports.__esModule = true;
    /*
        find the next state to go in the dfa
    */
    function moveDFA0(c, ret) {
        switch (ret.state) {
            case 0:
                ret.hasArc = true;
                ret.isEnd = false;
                if ((c >= 9 && c <= 10) || c === 13 || c === 32) {
                    ret.state = 1;
                }
                else if (c === 40) {
                    ret.state = 2;
                }
                else if (c === 41) {
                    ret.state = 3;
                }
                else if (c === 42) {
                    ret.state = 4;
                }
                else if (c === 43) {
                    ret.state = 5;
                }
                else if (c === 45) {
                    ret.state = 6;
                }
                else if (c === 46) {
                    ret.state = 7;
                }
                else if (c === 47) {
                    ret.state = 8;
                }
                else if ((c >= 48 && c <= 57)) {
                    ret.state = 9;
                }
                else if (c === 115) {
                    ret.state = 10;
                }
                else {
                    ret.state = -1;
                }
                break;
            case 1:
                ret.hasArc = true;
                ret.isEnd = true;
                if ((c >= 9 && c <= 10) || c === 13 || c === 32) {
                    ret.state = 1;
                }
                else {
                    ret.state = -1;
                }
                break;
            case 2:
                ret.hasArc = false;
                ret.isEnd = true;
                ret.state = -1;
                break;
            case 3:
                ret.hasArc = false;
                ret.isEnd = true;
                ret.state = -1;
                break;
            case 4:
                ret.hasArc = false;
                ret.isEnd = true;
                ret.state = -1;
                break;
            case 5:
                ret.hasArc = false;
                ret.isEnd = true;
                ret.state = -1;
                break;
            case 6:
                ret.hasArc = false;
                ret.isEnd = true;
                ret.state = -1;
                break;
            case 7:
                ret.hasArc = true;
                ret.isEnd = false;
                if ((c >= 48 && c <= 57)) {
                    ret.state = 11;
                }
                else {
                    ret.state = -1;
                }
                break;
            case 8:
                ret.hasArc = false;
                ret.isEnd = true;
                ret.state = -1;
                break;
            case 9:
                ret.hasArc = true;
                ret.isEnd = true;
                if (c === 46) {
                    ret.state = 12;
                }
                else if ((c >= 48 && c <= 57)) {
                    ret.state = 9;
                }
                else if (c === 69 || c === 101) {
                    ret.state = 13;
                }
                else {
                    ret.state = -1;
                }
                break;
            case 10:
                ret.hasArc = true;
                ret.isEnd = false;
                if (c === 105) {
                    ret.state = 14;
                }
                else {
                    ret.state = -1;
                }
                break;
            case 11:
                ret.hasArc = true;
                ret.isEnd = true;
                if ((c >= 48 && c <= 57)) {
                    ret.state = 11;
                }
                else if (c === 69 || c === 101) {
                    ret.state = 13;
                }
                else {
                    ret.state = -1;
                }
                break;
            case 12:
                ret.hasArc = true;
                ret.isEnd = true;
                if ((c >= 48 && c <= 57)) {
                    ret.state = 15;
                }
                else if (c === 69 || c === 101) {
                    ret.state = 13;
                }
                else {
                    ret.state = -1;
                }
                break;
            case 13:
                ret.hasArc = true;
                ret.isEnd = false;
                if ((c >= 48 && c <= 57)) {
                    ret.state = 16;
                }
                else {
                    ret.state = -1;
                }
                break;
            case 14:
                ret.hasArc = true;
                ret.isEnd = false;
                if (c === 110) {
                    ret.state = 17;
                }
                else {
                    ret.state = -1;
                }
                break;
            case 15:
                ret.hasArc = true;
                ret.isEnd = true;
                if ((c >= 48 && c <= 57)) {
                    ret.state = 15;
                }
                else if (c === 69 || c === 101) {
                    ret.state = 13;
                }
                else {
                    ret.state = -1;
                }
                break;
            case 16:
                ret.hasArc = true;
                ret.isEnd = true;
                if ((c >= 48 && c <= 57)) {
                    ret.state = 16;
                }
                else {
                    ret.state = -1;
                }
                break;
            case 17:
                ret.hasArc = true;
                ret.isEnd = true;
                if (c === 104) {
                    ret.state = 18;
                }
                else {
                    ret.state = -1;
                }
                break;
            case 18:
                ret.hasArc = false;
                ret.isEnd = true;
                ret.state = -1;
                break;
            default:
                ret.state = -1;
                ret.hasArc = false;
        }
    }
    /*
        all the lexer data goes here.
    */
    var jjlexers = [
        moveDFA0,
    ];
    /*
        tokens that a lexical dfa state can return
    */
    var jjlexTokens0 = [
        -1, -1, 6, 7, 4, 2, 3, -1, 5, 1,
        -1, 1, 1, -1, -1, 1, 1, 8, 9,
    ];
    var jjstateCount = 29;
    var jjtokenCount = 10;
    var jjactERR = 30;
    /*
        compressed action table: action = jjpact[jjdisact[STATE-NUM] + TOKEN]
        when action > 0, shift the token and goto state (action - 1);
        when action < 0, reduce with rule (1-action);
        when action = 0, do default action.
    */
    var jjpact = [
        4, 9, 10, 13, 12, 11, 8, 6, 7, 4,
        9, 10, 0, 0, 11, 0, 6, 7, 4, 9,
        10, 0, 0, 11, 0, 6, 7, 4, 9, 10,
        0, 0, 11, 0, 6, 7, 4, 9, 10, 0,
        0, 11, 0, 6, 7, 4, 9, 10, 0, 0,
        11, 0, 6, 7, 4, 9, 10, 0, 0, 11,
        0, 6, 7, 4, 9, 10, 0, 0, 11, 0,
        6, 7, 4, 9, 10, 0, 0, 11, 0, 6,
        7, 4, 9, 10, 0, 0, 11, 0, 6, 7,
        14, 15, 16, 17, 0, 29, 14, 15, 16, 17,
        0, 28, 14, 15, 16, 17, 0, 27, 14, 15,
        16, 17, 0, 0, 0, 0,
    ];
    /*
        displacement of action table.
    */
    var jjdisact = [
        80, 6, 106, -10, -10, -2, -3, -10, 71, 62,
        53, 44, 35, 26, 17, 8, -1, -10, -10, 100,
        94, 88, -10, -10, -10, -10, -10, -10, -10,
    ];
    /*
        used to check if a position in jjpact is out of bouds.
        if jjcheckact[jjdisact[STATE-NUM] + TOKEN] = STATE-NUM, this position is not out of bounds.
    */
    var jjcheckact = [
        16, 16, 16, 6, 5, 16, 1, 16, 16, 15,
        15, 15, 0, 0, 15, 0, 15, 15, 14, 14,
        14, 0, 0, 14, 0, 14, 14, 13, 13, 13,
        0, 0, 13, 0, 13, 13, 12, 12, 12, 0,
        0, 12, 0, 12, 12, 11, 11, 11, 0, 0,
        11, 0, 11, 11, 10, 10, 10, 0, 0, 10,
        0, 10, 10, 9, 9, 9, 0, 0, 9, 0,
        9, 9, 8, 8, 8, 0, 0, 8, 0, 8,
        8, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        21, 21, 21, 21, 0, 21, 20, 20, 20, 20,
        0, 20, 19, 19, 19, 19, 0, 19, 2, 2,
        2, 2, 0, 0, 0, 0,
    ];
    /*
        default action table. action = jjdefred[STATE-NUM],
        where action is the number of the rule to reduce with.
    */
    var jjdefred = [
        -1, -1, 1, 9, 10, -1, -1, 0, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 6, 7, -1,
        -1, -1, 2, 3, 4, 5, 8, 11, 12,
    ];
    /*
        compressed goto table: goto = jjpgoto[jjdisgoto[STATE-NUM] + NON_TERMINAL]
    */
    var jjpgoto = [
        25, 4, 24, 4, 23, 4, 22, 4, 21, 4,
        20, 4, 19, 4, 18, 4, 17, 4, 1, 2,
        4,
    ];
    /*
        displacement of the goto table
    */
    var jjdisgoto = [
        17, -4, -4, -4, -4, -4, -4, -4, 14, 12,
        10, 8, 6, 4, 2, 0, -2, -4, -4, -4,
        -4, -4, -4, -4, -4, -4, -4, -4, -4,
    ];
    /*
        length of each rule: rule length = jjruleLen[RULE-NUM]
    */
    var jjruleLen = [
        2, 1, 3, 3, 3, 3, 2, 2, 3, 1,
        1, 4, 4,
    ];
    /*
        index of the LHS of each rule
    */
    var jjlhs = [
        0, 1, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 3, 3,
    ];
    /*
        token names
    */
    var jjtokenNames = [
        "EOF", "NUM", "PLUS",
        "MINUS", "TIMES", "DIVIDE",
        "BRA", "KET", "SIN",
        "SINH",
    ];
    /*
        token alias
    */
    var jjtokenAlias = [
        null, null, "+",
        "-", "*", "/",
        "(", ")", "sin",
        "sinh",
    ];
    function tokenToString(tk) {
        return jjtokenAlias[tk] === null ? "<" + jjtokenNames[tk] + ">" : "\"" + jjtokenAlias[tk] + "\"";
    }
    exports.tokenToString = tokenToString;
    var Token = /** @class */ (function () {
        function Token(id, val, startLine, startColumn, endLine, endColumn) {
            this.id = id;
            this.val = val;
            this.startLine = startLine;
            this.startColumn = startColumn;
            this.endLine = endLine;
            this.endColumn = endColumn;
        }
        Token.prototype.toString = function () {
            return (jjtokenAlias[this.id] === null ?
                "<" + jjtokenNames[this.id] + ">" :
                "\"" + jjtokenAlias[this.id] + "\"") + ("(\"" + this.val + "\")");
        };
        return Token;
    }());
    exports.Token = Token;
    var Parser = /** @class */ (function () {
        function Parser() {
            this._marker = { state: -1, line: 0, column: 0 };
            // members for parser
            this._lrState = [];
            this._sematicS = [];
            this._handlers = {};
            this.init();
        }
        Parser.prototype.init = function () {
            this._lexState = [0]; // DEFAULT
            this._state = 0;
            this._matched = '';
            this._token = null;
            this._marker.state = -1;
            this._backupCount = 0;
            this._line = this._tline = 1;
            this._column = this._tcolumn = 1;
            this._lrState = [0];
            this._sematicS = [];
            this._sematicVal = null;
            this._stop = false;
        };
        /**
         *  set
         */
        Parser.prototype._setImg = function (s) {
            this._matched = s;
            this._tline = this._line;
            this._tcolumn = this._column;
        };
        Parser.prototype._prepareToken = function (tid) {
            this._token = new Token(tid, this._matched, this._tline, this._tcolumn, this._line, this._column);
            this._matched = '';
            this._tline = this._line;
            this._tcolumn = this._column;
        };
        Parser.prototype._returnToken = function () {
            this._emit('token', jjtokenNames[this._token.id], this._token.val);
            while (!this._stop && !this._acceptToken(this._token))
                ;
            this._token = null;
        };
        Parser.prototype._emit = function (name, a1, a2, a3) {
            var cbs = this._handlers[name];
            if (cbs) {
                for (var _i = 0, cbs_1 = cbs; _i < cbs_1.length; _i++) {
                    var cb = cbs_1[_i];
                    cb(a1, a2, a3);
                }
            }
        };
        Parser.prototype.on = function (name, cb) {
            this._handlers[name] || (this._handlers[name] = []);
            this._handlers[name].push(cb);
        };
        Parser.prototype._doLexAction0 = function (jjstaten) {
            var jjtk = jjlexTokens0[jjstaten];
            jjtk !== -1 && this._prepareToken(jjtk);
            switch (jjstaten) {
                case 1:
                    this._setImg("");
                    break;
                case 9:
                    this._sematicVal = Number(this._token.val);
                    break;
                case 11:
                    this._sematicVal = Number(this._token.val);
                    break;
                case 12:
                    this._sematicVal = Number(this._token.val);
                    break;
                case 15:
                    this._sematicVal = Number(this._token.val);
                    break;
                case 16:
                    this._sematicVal = Number(this._token.val);
                    break;
                default: ;
            }
        };
        /**
         *  do a lexical action
         *  @api private
         *  @internal
         */
        Parser.prototype._doLexAction = function (lexstate, state) {
            switch (lexstate) {
                case 0:
                    this._doLexAction0(state);
                    break;
                default: ;
            }
            this._token !== null && this._returnToken();
        };
        Parser.prototype._rollback = function () {
            var ret = this._matched.substr(this._matched.length - this._backupCount, this._backupCount);
            this._matched = this._matched.substr(0, this._matched.length - this._backupCount);
            this._backupCount = 0;
            this._line = this._marker.line;
            this._column = this._marker.column;
            this._state = this._marker.state;
            this._marker.state = -1;
            return ret;
        };
        Parser.prototype._mark = function () {
            this._marker.state = this._state;
            this._marker.line = this._line;
            this._marker.column = this._column;
            this._backupCount = 0;
        };
        /**
         *  accept a character
         *  @return - true if the character is consumed, false if not consumed
         *  @api private
         *  @internal
         */
        Parser.prototype._acceptChar = function (c) {
            function consume(cela, c) {
                c === '\n' ? (cela._line++, cela._column = 0) : (cela._column++);
                cela._matched += c;
                cela._marker.state !== -1 && (cela._backupCount++);
                return true;
            }
            var lexstate = this._lexState[this._lexState.length - 1];
            var retn = { state: this._state, hasArc: false, isEnd: false };
            jjlexers[lexstate](c.charCodeAt(0), retn);
            if (retn.isEnd) {
                // if current state is a terminate state, be careful
                if (retn.hasArc) {
                    if (retn.state === -1) {
                        // nowhere to go, stay where we are
                        this._doLexAction(lexstate, this._state);
                        // recover
                        this._marker.state = -1;
                        this._backupCount = 0;
                        this._state = 0;
                        // character not consumed
                        return false;
                    }
                    else {
                        // now we can either go to that new state, or stay where we are
                        // it is prefered to move forward, but that could lead to errors,
                        // so we need to memorize this state before move on, in case if 
                        // an error occurs later, we could just return to this state.
                        this._mark();
                        this._state = retn.state;
                        return consume(this, c);
                    }
                }
                else {
                    // current state doesn't lead to any state, just stay here.
                    this._doLexAction(lexstate, this._state);
                    // recover
                    this._marker.state = -1;
                    this._backupCount = 0;
                    this._state = 0;
                    // character not consumed
                    return false;
                }
            }
            else {
                if (retn.state === -1) {
                    // nowhere to go at current state, error may have occured.
                    // check marker to verify that
                    if (this._marker.state !== -1) {
                        // we have a previously marked state, which is a terminate state.
                        var s = this._rollback();
                        this._doLexAction(lexstate, this._state);
                        this._state = 0;
                        this.accept(s);
                        // character not consumed
                        return false;
                    }
                    else {
                        // error occurs
                        this._emit('lexicalerror', "unexpected character \"" + c + "\"", this._line, this._column);
                        // force consume
                        return true;
                    }
                }
                else {
                    this._state = retn.state;
                    // character consumed
                    return consume(this, c);
                }
            }
        };
        Parser.prototype._acceptEOF = function () {
            if (this._state === 0) {
                // recover
                this._prepareToken(0);
                this._returnToken();
                return true;
            }
            else {
                var lexstate = this._lexState[this._lexState.length - 1];
                var retn = { state: this._state, hasArc: false, isEnd: false };
                jjlexers[lexstate](-1, retn);
                if (retn.isEnd) {
                    this._doLexAction(lexstate, this._state);
                    this._state = 0;
                    this._marker.state = -1;
                    return false;
                }
                else if (this._marker.state !== -1) {
                    var s = this._rollback();
                    this._doLexAction(lexstate, this._state);
                    this._state = 0;
                    this.accept(s);
                    return false;
                }
                else {
                    this._emit('lexicalerror', 'unexpected end of file');
                    return true;
                }
            }
        };
        /**
         *  input a string
         *  @api public
         */
        Parser.prototype.accept = function (s) {
            for (var i = 0; i < s.length && !this._stop;) {
                this._acceptChar(s.charAt(i)) && i++;
            }
        };
        /**
         *  tell the compiler that end of file is reached
         *  @api public
         */
        Parser.prototype.end = function () {
            while (!this._stop && !this._acceptEOF())
                ;
            this._stop = true;
        };
        Parser.prototype.halt = function () {
            this._stop = true;
        };
        Parser.prototype._doReduction = function (jjrulenum) {
            var jjnt = jjlhs[jjrulenum];
            var jjsp = this._sematicS.length;
            var jjtop = this._sematicS[jjsp - jjruleLen[jjrulenum]] || null;
            switch (jjrulenum) {
                case 1:
                    /* 1: start => expr */
                    var a = this._sematicS[jjsp - 1];
                    {
                        this.val = a;
                    }
                    break;
                case 2:
                    /* 2: expr => expr "+" expr */
                    var a = this._sematicS[jjsp - 3];
                    var b = this._sematicS[jjsp - 1];
                    {
                        jjtop = a + b;
                    }
                    break;
                case 3:
                    /* 3: expr => expr "-" expr */
                    var a = this._sematicS[jjsp - 3];
                    var b = this._sematicS[jjsp - 1];
                    {
                        jjtop = a - b;
                    }
                    break;
                case 4:
                    /* 4: expr => expr "*" expr */
                    var a = this._sematicS[jjsp - 3];
                    var b = this._sematicS[jjsp - 1];
                    {
                        jjtop = a * b;
                    }
                    break;
                case 5:
                    /* 5: expr => expr "/" expr */
                    var a = this._sematicS[jjsp - 3];
                    var b = this._sematicS[jjsp - 1];
                    {
                        jjtop = a / b;
                    }
                    break;
                case 6:
                    /* 6: expr => "+" expr */
                    var a = this._sematicS[jjsp - 1];
                    {
                        jjtop = a;
                    }
                    break;
                case 7:
                    /* 7: expr => "-" expr */
                    var a = this._sematicS[jjsp - 1];
                    {
                        jjtop = -a;
                    }
                    break;
                case 8:
                    /* 8: expr => "(" expr ")" */
                    var a = this._sematicS[jjsp - 2];
                    {
                        jjtop = a;
                    }
                    break;
                case 11:
                    /* 11: funcs => "sin" "(" expr ")" */
                    var a = this._sematicS[jjsp - 2];
                    {
                        jjtop = Math.sin(a);
                    }
                    break;
                case 12:
                    /* 12: funcs => "sinh" "(" expr ")" */
                    var a = this._sematicS[jjsp - 2];
                    {
                        jjtop = Math.sinh(a);
                    }
                    break;
            }
            this._lrState.length -= jjruleLen[jjrulenum];
            var jjcstate = this._lrState[this._lrState.length - 1];
            this._lrState.push(jjpgoto[jjdisgoto[jjcstate] + jjnt]);
            this._sematicS.length -= jjruleLen[jjrulenum];
            this._sematicS.push(jjtop);
        };
        Parser.prototype._acceptToken = function (t) {
            // look up action table
            var cstate = this._lrState[this._lrState.length - 1];
            var ind = jjdisact[cstate] + t.id;
            var act = 0;
            if (ind < 0 || ind >= jjpact.length || jjcheckact[ind] !== cstate) {
                act = -jjdefred[cstate] - 1;
            }
            else {
                act = jjpact[ind];
            }
            if (act === jjactERR) {
                // explicit error
                this._syntaxError(t);
                return true;
            }
            else if (act > 0) {
                // shift
                if (t.id === 0) {
                    // end of file
                    this._stop = true;
                    this._emit('accept');
                    return true;
                }
                else {
                    this._lrState.push(act - 1);
                    this._sematicS.push(this._sematicVal);
                    this._sematicVal = null;
                    // token consumed
                    return true;
                }
            }
            else if (act < 0) {
                this._doReduction(-act - 1);
                return false;
            }
            else {
                // error
                this._syntaxError(t);
                // force consume
                return true;
            }
        };
        Parser.prototype._syntaxError = function (t) {
            var msg = "unexpected token " + t.toString() + ", expecting one of the following token(s):\n";
            msg += this._expected(this._lrState[this._lrState.length - 1]);
            this._emit("syntaxerror", msg, t);
        };
        Parser.prototype._expected = function (state) {
            var dis = jjdisact[state];
            var ret = '';
            function expect(tk) {
                var ind = dis + tk;
                if (ind < 0 || ind >= jjpact.length || state !== jjcheckact[ind]) {
                    return jjdefred[state] !== -1;
                }
                else {
                    return true;
                }
            }
            for (var tk = 0; tk < jjtokenCount; tk++) {
                expect(tk) && (ret += "    " + tokenToString(tk) + " ..." + '\n');
            }
            return ret;
        };
        return Parser;
    }());
    exports.Parser = Parser;
});
//# sourceMappingURL=calculator.js.map