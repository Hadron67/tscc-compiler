{"code":"import { State, EndAction } from './state';\r\nimport { DFA } from './dfa';\r\nimport { compile, compileRaw } from './compile';\r\nfunction lexerBuilder(regs) {\r\n    if (regs === void 0) { regs = {}; }\r\n    var stateCount = 0;\r\n    var actions = [];\r\n    var pr = 0;\r\n    function ns() {\r\n        var ret = new State();\r\n        ret.index = stateCount++;\r\n        return ret;\r\n    }\r\n    var head = ns();\r\n    return {\r\n        lexRule: function (reg, id, data, raw) {\r\n            var action = new EndAction();\r\n            action.priority = pr++;\r\n            action.id = id;\r\n            action.data = data || null;\r\n            var cpd = (!!raw ? compileRaw(reg, stateCount) : compile(reg, stateCount, regs));\r\n            stateCount += cpd.stateCount;\r\n            cpd.tail.endAction = action;\r\n            head.epsilonTo(cpd.result);\r\n            actions.push(action);\r\n        },\r\n        done: function () {\r\n            head.removeEpsilons();\r\n            var dhead = head.toDFA();\r\n            var ret = new DFA(dhead.states, actions);\r\n            return ret;\r\n        }\r\n    };\r\n}\r\nfunction lexer(defs, regs) {\r\n    var getdef;\r\n    if (typeof defs !== 'function') {\r\n        getdef = function () {\r\n            return defs.shift() || null;\r\n        };\r\n    }\r\n    else {\r\n        getdef = defs;\r\n    }\r\n    var bd = lexerBuilder(regs);\r\n    var def = getdef();\r\n    while (def !== null) {\r\n        bd.lexRule(def.regexp, def.id, def.data, def.raw);\r\n        def = getdef();\r\n    }\r\n    return bd.done();\r\n}\r\nexport { lexer, lexerBuilder };\r\n","map":{"mappings":""}}
