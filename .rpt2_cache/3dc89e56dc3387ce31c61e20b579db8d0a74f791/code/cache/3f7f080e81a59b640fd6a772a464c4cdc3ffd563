{"code":"import { PatternException as E } from './pattern-exception.js';\r\nimport { State } from './state.js';\r\nfunction stackReader(str, strs) {\r\n    var stack = [{ sptr: 0, s: str, name: '' }];\r\n    var top = stack[0];\r\n    function checkNested(name) {\r\n        for (var i = 0; i < stack.length; i++) {\r\n            if (stack[i].name === name) {\r\n                throw new E('cannot use pattern \"' + name + '\" which leads to loop reference');\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        next: function () {\r\n            top.sptr++;\r\n            if (top.sptr >= top.s.length) {\r\n                stack.length > 1 && stack.pop();\r\n                top = stack[stack.length - 1];\r\n            }\r\n        },\r\n        peek: function () {\r\n            return top.s[top.sptr] || null;\r\n        },\r\n        pushTo: function (name) {\r\n            var nn = strs ? strs[name] : null;\r\n            if (!nn) {\r\n                throw new E('undefined name \"' + name + '\"');\r\n            }\r\n            checkNested(name);\r\n            stack.push({ sptr: 0, s: '(' + nn + ')', name: name });\r\n            top = stack[stack.length - 1];\r\n        }\r\n    };\r\n}\r\nexport function compile(input, stateCount, regs) {\r\n    if (stateCount === void 0) { stateCount = 0; }\r\n    if (regs === void 0) { regs = {}; }\r\n    stateCount = stateCount || 0;\r\n    var stateCountDelta = 0;\r\n    var reader = stackReader(input, regs);\r\n    var c = reader.peek();\r\n    function nc() {\r\n        reader.next();\r\n        c = reader.peek();\r\n    }\r\n    function notEof(reason) {\r\n        if (c === null) {\r\n            throw new E('unexpected end of string' + (reason ? ', ' + reason : ''));\r\n        }\r\n    }\r\n    function ns() {\r\n        var s = new State();\r\n        s.index = stateCount++;\r\n        stateCountDelta++;\r\n        return s;\r\n    }\r\n    function eof() {\r\n        return c === null;\r\n    }\r\n    function expect(c1) {\r\n        if (c !== c1) {\r\n            throw new E('unexpected character \"' + c + '\",expecting \"' + c1 + '\"');\r\n        }\r\n        nc();\r\n    }\r\n    function rexp(start) {\r\n        var ret = simpleRE(start);\r\n        while (!eof() && c === '|') {\r\n            nc();\r\n            var es = ns();\r\n            start.epsilonTo(es);\r\n            simpleRE(es).epsilonTo(ret);\r\n        }\r\n        return ret;\r\n    }\r\n    function simpleRE(start) {\r\n        var ret = start;\r\n        do {\r\n            ret = basicRE(ret);\r\n        } while (!eof() && c !== '|' && c !== ')');\r\n        return ret;\r\n    }\r\n    function basicRE(start) {\r\n        var holder = ns();\r\n        start.epsilonTo(holder);\r\n        var ret = primitive(holder);\r\n        if (c === '*') {\r\n            nc();\r\n            ret.epsilonTo(holder);\r\n            var nn = ns();\r\n            holder.epsilonTo(nn);\r\n            return nn;\r\n        }\r\n        else if (c === '+') {\r\n            nc();\r\n            var count = ns();\r\n            ret.epsilonTo(count);\r\n            count.epsilonTo(holder);\r\n            return count;\r\n        }\r\n        else if (c === '?') {\r\n            nc();\r\n            var nn2 = ns();\r\n            holder.epsilonTo(nn2);\r\n            ret.epsilonTo(nn2);\r\n            return nn2;\r\n        }\r\n        else {\r\n            return ret;\r\n        }\r\n    }\r\n    function primitive(start) {\r\n        notEof();\r\n        if (c === '(') {\r\n            nc();\r\n            var ret = rexp(start);\r\n            expect(')');\r\n            return ret;\r\n        }\r\n        else if (c === '.') {\r\n            nc();\r\n            var ret2 = ns();\r\n            start.to(ret).chars.addAll();\r\n            return ret;\r\n        }\r\n        else if (c === '[') {\r\n            nc();\r\n            var neg = c === '^';\r\n            neg && nc();\r\n            var ret3 = ns();\r\n            var set = start.to(ret).chars;\r\n            neg && set.addAll();\r\n            while (c !== ']' && !eof()) {\r\n                setItem(set, neg);\r\n            }\r\n            expect(']');\r\n            return ret;\r\n        }\r\n        else if (c === '{') {\r\n            nc();\r\n            var name = '';\r\n            while (c !== '}') {\r\n                notEof();\r\n                name += c;\r\n                nc();\r\n            }\r\n            nc();\r\n            reader.pushTo(name);\r\n            c = reader.peek();\r\n            return simpleRE(start);\r\n        }\r\n        else {\r\n            var ret4 = ns();\r\n            start.to(ret).chars.add(gchar());\r\n            return ret;\r\n        }\r\n    }\r\n    function gchar() {\r\n        notEof();\r\n        if (c === '\\\\') {\r\n            nc();\r\n            var ret = c.charCodeAt(0);\r\n            switch (c) {\r\n                case 't': ret = '\\t';\r\n                case 'n': ret = '\\n';\r\n                case 'r': ret = '\\r';\r\n                case 'x':\r\n                    nc();\r\n                    var code = '';\r\n                    while (c !== null && /[0-9a-fA-F]/.test(c)) {\r\n                        code += c;\r\n                        nc();\r\n                    }\r\n                    return parseInt(code, 16);\r\n                default: ret = c;\r\n            }\r\n            nc();\r\n            return ret.charCodeAt(0);\r\n        }\r\n        else {\r\n            var ret = c.charCodeAt(0);\r\n            nc();\r\n            return ret;\r\n        }\r\n    }\r\n    function setItem(set, neg) {\r\n        var s = gchar();\r\n        var from = s, to = s;\r\n        if (c === '-') {\r\n            nc();\r\n            to = gchar();\r\n            if (to < from) {\r\n                throw new E('left hand side must be larger than right hand side in wild card character (got '\r\n                    + from.toString(16) + ' < '\r\n                    + to.toString(16) + ')');\r\n            }\r\n        }\r\n        if (neg) {\r\n            set.remove(from, to);\r\n        }\r\n        else {\r\n            set.add(from, to);\r\n        }\r\n    }\r\n    var head = ns();\r\n    head.isStart = true;\r\n    var tail = rexp(head);\r\n    return {\r\n        result: head,\r\n        tail: tail,\r\n        stateCount: stateCountDelta\r\n    };\r\n}\r\nexport function compileRaw(input, stateCount) {\r\n    if (stateCount === void 0) { stateCount = 0; }\r\n    var sptr = 0;\r\n    var stateCountDelta = 0;\r\n    var c = input.charAt(sptr);\r\n    function ns() {\r\n        var s = new State();\r\n        s.index = stateCount++;\r\n        stateCountDelta++;\r\n        return s;\r\n    }\r\n    function nc() {\r\n        c = input.charAt(++sptr) || null;\r\n    }\r\n    function eof() {\r\n        return c === null;\r\n    }\r\n    var head = ns();\r\n    head.isStart = true;\r\n    var tail = head;\r\n    while (!eof()) {\r\n        var s = ns();\r\n        tail.to(s).chars.add(c.charCodeAt(0));\r\n        tail = s;\r\n        nc();\r\n    }\r\n    return {\r\n        result: head,\r\n        tail: tail,\r\n        stateCount: stateCountDelta\r\n    };\r\n}\r\n","map":{"mappings":""}}
