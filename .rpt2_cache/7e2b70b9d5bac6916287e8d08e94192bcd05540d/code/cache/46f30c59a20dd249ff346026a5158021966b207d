{"code":"import { TokenSet } from './token-set';\r\nexport var Action;\r\n(function (Action) {\r\n    Action[Action[\"NONE\"] = 1] = \"NONE\";\r\n    Action[Action[\"SHIFT\"] = 2] = \"SHIFT\";\r\n    Action[Action[\"REDUCE\"] = 3] = \"REDUCE\";\r\n})(Action || (Action = {}));\r\nexport class Item {\r\n    constructor(rule, ik) {\r\n        this.marker = 0;\r\n        this.shift = null;\r\n        this.actionType = Action.NONE;\r\n        this.changed = true;\r\n        this.rule = rule;\r\n        this.isKernel = ik;\r\n        this.lah = new TokenSet(rule.g.tokenCount);\r\n    }\r\n    canShift() {\r\n        return this.rule.rhs.length > this.marker;\r\n    }\r\n    getShift() {\r\n        return this.rule.rhs[this.marker];\r\n    }\r\n    toString(opt = {}) {\r\n        var showlah = (opt && opt.showlah) || false;\r\n        var showTrailer = (opt && opt.showTrailer) || false;\r\n        var r = this.rule;\r\n        var ret = '[ ' + this.rule.toString(this.marker) + (showlah ? ',{ ' + this.lah.toString(this.rule.g) + ' }' : '') + ' ]';\r\n        this.isKernel && (ret += '*');\r\n        if (showTrailer) {\r\n            switch (this.actionType) {\r\n                case Action.NONE:\r\n                    ret += '(-)';\r\n                    break;\r\n                case Action.SHIFT:\r\n                    ret += '(s' + this.shift.stateIndex + ')';\r\n                    break;\r\n                case Action.REDUCE:\r\n                    ret += '(r)';\r\n                    break;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    hash() {\r\n        return this.rule.index + '-' + this.marker;\r\n    }\r\n    hasRRConflictWith(i) {\r\n        return this.actionType === Action.REDUCE && i.actionType === Action.REDUCE && this.rule.index !== i.rule.index && this.lah.hasIntersection(i.lah);\r\n    }\r\n    getFollowSet(set) {\r\n        var g = this.rule.g;\r\n        var i;\r\n        for (i = this.marker + 1; i < this.rule.rhs.length; i++) {\r\n            var mItem = this.rule.rhs[i];\r\n            if (g.isToken(mItem)) {\r\n                set.add(mItem + 1);\r\n                break;\r\n            }\r\n            else {\r\n                var set1 = g.nts[mItem - g.tokenCount].firstSet;\r\n                set.union(set1);\r\n                set.remove(0);\r\n                if (!set1.contains(0)) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (i === this.rule.rhs.length) {\r\n            set.union(this.lah);\r\n        }\r\n    }\r\n}\r\nItem.NULL = {};\r\nexport class ItemSet {\r\n    constructor(g) {\r\n        this.it = {};\r\n        this.complete = false;\r\n        this.index = -1;\r\n        this.stateIndex = 0;\r\n        this.prev = null;\r\n        this.next = null;\r\n        this.merges = [];\r\n        this.g = g;\r\n        this.data = this;\r\n    }\r\n    add(rule, marker, ik, lah, reset) {\r\n        var h = rule.index + '-' + marker;\r\n        var it = this.it[h];\r\n        if (it === undefined) {\r\n            var n = new Item(rule, ik);\r\n            n.marker = marker;\r\n            if (lah) {\r\n                n.lah.union(lah);\r\n            }\r\n            this.it[h] = n;\r\n            return true;\r\n        }\r\n        else if (lah) {\r\n            var ret = it.lah.union(lah);\r\n            if (reset && ret && it.canShift()) {\r\n                it.actionType = Action.NONE;\r\n            }\r\n            ret && (it.changed = true);\r\n            return ret;\r\n        }\r\n    }\r\n    contains() {\r\n    }\r\n    closure() {\r\n        var changed = true;\r\n        var tSet = new TokenSet(this.g.tokenCount);\r\n        var cela = this;\r\n        while (changed) {\r\n            changed = false;\r\n            for (var hash in this.it) {\r\n                var item = this.it[hash];\r\n                if (item.changed && item.canShift()) {\r\n                    var ritem = item.getShift();\r\n                    if (!this.g.isToken(ritem)) {\r\n                        tSet.removeAll();\r\n                        item.getFollowSet(tSet);\r\n                        this.g.forEachRuleOfNt(ritem - this.g.tokenCount, function (rule) {\r\n                            changed = cela.add(rule, 0, false, tSet, false) || changed;\r\n                            return false;\r\n                        });\r\n                    }\r\n                }\r\n                item.changed = false;\r\n            }\r\n        }\r\n    }\r\n    toString(opt) {\r\n        var showlah = (opt && opt.showlah) || false;\r\n        var showTrailer = (opt && opt.showTrailer) || false;\r\n        var opt2 = { showTrailer: showTrailer };\r\n        var ret = 's' + this.stateIndex + '';\r\n        if (this.index !== null) {\r\n            ret += '(i' + this.index;\r\n        }\r\n        else {\r\n            ret += '(i?';\r\n        }\r\n        if (this.merges.length > 0) {\r\n            ret += ',merged from ';\r\n            for (var i = 0; i < this.merges.length; i++) {\r\n                if (i > 0) {\r\n                    ret += ',';\r\n                }\r\n                ret += 'i' + this.merges[i];\r\n            }\r\n        }\r\n        ret += ')\\n';\r\n        for (var hash in this.it) {\r\n            ret += this.it[hash].toString(opt2) + '\\n';\r\n        }\r\n        return ret;\r\n    }\r\n    kernelHash() {\r\n        var ret = 0;\r\n        for (var hash in this.it) {\r\n            var item = this.it[hash];\r\n            if (item.isKernel) {\r\n                ret += item.rule.index << 5 + item.rule.index + item.marker;\r\n            }\r\n        }\r\n        return String(ret);\r\n    }\r\n    forEach(cb) {\r\n        for (var h in this.it) {\r\n            cb(this.it[h]);\r\n        }\r\n    }\r\n    canMergeTo(s) {\r\n        for (var h1 in this.it) {\r\n            var it1 = this.it[h1];\r\n            var found = false, hasConflict = false, hasIdentical = false;\r\n            for (var h2 in s.it) {\r\n                var it2 = s.it[h2];\r\n                if (it1.rule.index === it2.rule.index && it1.marker === it2.marker) {\r\n                    hasIdentical = it1.lah.equals(it2.lah);\r\n                    found = it1.isKernel && it2.isKernel;\r\n                }\r\n                hasConflict = hasConflict || it1.hasRRConflictWith(it2);\r\n                if (it2.isKernel && this.it[h2] === undefined) {\r\n                    return false;\r\n                }\r\n            }\r\n            if (it1.isKernel && !found || hasConflict && !hasIdentical) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    mergeTo(s) {\r\n        var ret = false;\r\n        for (var h in s.it) {\r\n            var it = s.it[h];\r\n            ret = this.add(it.rule, it.marker, it.isKernel, it.lah, true) || ret;\r\n        }\r\n        this.merges.push(s.index);\r\n        return ret;\r\n    }\r\n}\r\n","map":{"mappings":""}}
