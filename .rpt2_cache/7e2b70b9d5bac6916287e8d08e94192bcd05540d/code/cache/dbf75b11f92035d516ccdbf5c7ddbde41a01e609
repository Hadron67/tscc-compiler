{"code":"import { DEBUG } from './common';\r\nfunction copyArray(a) {\r\n    var ret = [];\r\n    for (var i = 0; i < a.length; i++) {\r\n        ret.push(a[i]);\r\n    }\r\n    return ret;\r\n}\r\nfunction cm(a, b) {\r\n    if ((a === Inf.oo && b !== Inf.oo) || (a !== Inf._oo && b === Inf._oo) || a > b) {\r\n        return 1;\r\n    }\r\n    else if ((a === Inf._oo && b !== Inf._oo) || (a !== Inf.oo && b === Inf.oo) || a < b) {\r\n        return -1;\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n}\r\nexport var Inf;\r\n(function (Inf) {\r\n    Inf[\"oo\"] = \"oo\";\r\n    Inf[\"_oo\"] = \"-oo\";\r\n})(Inf || (Inf = {}));\r\n;\r\nclass Interval {\r\n    constructor(a, b) {\r\n        this.a = a;\r\n        this.b = b;\r\n    }\r\n    insertBefore(a, b, data) {\r\n        if (this.parent.isValid(this) && !this.parent.noMerge && this.a === b + 1) {\r\n            this.a = a;\r\n            return this;\r\n        }\r\n        else {\r\n            var it = this.parent.createInterval(a, b, data);\r\n            it.prev = this.prev;\r\n            it.next = this;\r\n            this.prev.next = it;\r\n            this.prev = it;\r\n            return it;\r\n        }\r\n    }\r\n    contains(a) {\r\n        return cm(this.a, a) <= 0 && cm(this.b, a) >= 0;\r\n    }\r\n    overlaps(a, b) {\r\n        return !(cm(a, this.b) > 0 || cm(b, this.a) < 0);\r\n    }\r\n    insertAfter(a, b, data) {\r\n        if (this.parent.isValid(this) && !this.parent.noMerge && this.b === a - 1) {\r\n            this.b = b;\r\n            return this;\r\n        }\r\n        else {\r\n            var it = this.parent.createInterval(a, b, data);\r\n            it.prev = this;\r\n            it.next = this.next;\r\n            this.next.prev = it;\r\n            this.next = it;\r\n            return it;\r\n        }\r\n    }\r\n    splitLeft(a) {\r\n        if (cm(a, this.a) > 0) {\r\n            var ret = this.insertBefore(this.a, a - 1);\r\n            this.parent.noMerge && ret.dataSet.union(this.dataSet);\r\n            this.a = a;\r\n            return ret;\r\n        }\r\n        return this;\r\n    }\r\n    splitRight(b) {\r\n        if (cm(b, this.b) < 0) {\r\n            var ret = this.insertAfter(b + 1, this.b);\r\n            this.parent.noMerge && ret.dataSet.union(this.dataSet);\r\n            this.b = b;\r\n            return ret;\r\n        }\r\n        return this;\r\n    }\r\n    remove() {\r\n        this.prev.next = this.next;\r\n        this.next.prev = this.prev;\r\n        return this;\r\n    }\r\n    checkMerge() {\r\n        if (this.a !== Inf._oo && this.prev.a !== null && this.a === this.prev.b + 1) {\r\n            this.a = this.prev.a;\r\n            this.prev.remove();\r\n        }\r\n        if (this.b !== Inf.oo && this.next.a !== null && this.b === this.next.a - 1) {\r\n            this.b = this.next.b;\r\n            this.next.remove();\r\n        }\r\n        return this;\r\n    }\r\n    toString(mapper) {\r\n        var ret = '';\r\n        function dfmapper(c) {\r\n            return c === Inf.oo ? '+oo' : c === Inf._oo ? '-oo' : c.toString();\r\n        }\r\n        var a = (mapper || dfmapper)(this.a);\r\n        var b = (mapper || dfmapper)(this.b);\r\n        if (this.a === this.b) {\r\n            ret += a;\r\n        }\r\n        else {\r\n            ret += this.a === Inf._oo ? '(' + a : '[' + a;\r\n            ret += ',';\r\n            ret += this.b === Inf.oo ? b + ')' : b + ']';\r\n        }\r\n        this.dataSet && (ret += this.dataSet.toString());\r\n        return ret;\r\n    }\r\n}\r\nfunction checkArg(a, b) {\r\n    if (cm(a, b) > 0) {\r\n        throw new Error(`illegal argument: \"a\"(${a}) must be no more than \"b\"(${b})`);\r\n    }\r\n}\r\nexport class IntervalSet {\r\n    constructor(dataSetConstructor) {\r\n        this.head = new Interval(0, 0);\r\n        this.head.parent = this;\r\n        this.tail = new Interval(null, null);\r\n        this.tail.parent = this;\r\n        this.head.next = this.tail;\r\n        this.tail.prev = this.head;\r\n        this.noMerge = typeof dataSetConstructor !== 'undefined';\r\n        this.dataSetConstructor = dataSetConstructor || null;\r\n    }\r\n    isValid(it) {\r\n        return it !== this.head && it !== this.tail;\r\n    }\r\n    createInterval(a, b, data) {\r\n        var ret = new Interval(a, b);\r\n        ret.parent = this;\r\n        this.dataSetConstructor && (ret.dataSet = this.dataSetConstructor());\r\n        data && ret.dataSet.add(data);\r\n        return ret;\r\n    }\r\n    fitPoint(a, b) {\r\n        for (var it = this.head; it !== this.tail; it = it.next) {\r\n            if ((it === this.head || cm(a, it.b) > 0) && (it.next === this.tail || cm(b, it.next.a) < 0)) {\r\n                return it;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    overlaped(a, b) {\r\n        var start = null, end = null;\r\n        var it = this.head.next;\r\n        for (; it !== this.tail && !it.overlaps(a, b); it = it.next)\r\n            ;\r\n        if (it === this.tail) {\r\n            return null;\r\n        }\r\n        start = end = it;\r\n        for (; it !== this.tail && it.overlaps(a, b); it = it.next) {\r\n            end = it;\r\n        }\r\n        return [start, end];\r\n    }\r\n    add(a, b = a, data) {\r\n        var noMerge = this.noMerge;\r\n        DEBUG && checkArg(a, b);\r\n        var overlap = this.overlaped(a, b);\r\n        if (overlap === null) {\r\n            this.fitPoint(a, b).insertAfter(a, b, data);\r\n        }\r\n        else {\r\n            if (!noMerge) {\r\n                var a1 = cm(a, overlap[0].a) < 0 ? a : overlap[0].a;\r\n                var b1 = cm(b, overlap[1].b) > 0 ? b : overlap[1].b;\r\n                overlap[0].a = a1;\r\n                overlap[0].b = b1;\r\n                overlap[0].next = overlap[1].next;\r\n                overlap[1].next.prev = overlap[0];\r\n                overlap[0].checkMerge();\r\n            }\r\n            else {\r\n                if (overlap[0].contains(a)) {\r\n                    overlap[0].splitLeft(a);\r\n                }\r\n                else {\r\n                    overlap[0].insertBefore(a, overlap[0].a - 1, data);\r\n                }\r\n                if (overlap[1].contains(b)) {\r\n                    overlap[1].splitRight(b);\r\n                }\r\n                else {\r\n                    overlap[1].insertAfter(overlap[1].b + 1, b, data);\r\n                }\r\n                for (var it = overlap[0]; it !== overlap[1]; it = it.next) {\r\n                    it.dataSet.add(data);\r\n                    if (it.b + 1 < it.next.a) {\r\n                        it.insertAfter(it.b + 1, it.next.a - 1, data);\r\n                    }\r\n                }\r\n                overlap[1].dataSet.add(data);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    remove(a, b) {\r\n        checkArg(a, b);\r\n        var overlap = this.overlaped(a, b);\r\n        if (overlap !== null) {\r\n            overlap[0].contains(a) && overlap[0].splitLeft(a);\r\n            overlap[1].contains(b) && overlap[1].splitRight(b);\r\n            overlap[0].prev.next = overlap[1].next;\r\n            overlap[1].next.prev = overlap[0].prev;\r\n        }\r\n        return this;\r\n    }\r\n    removeAll() {\r\n        this.head.next = this.tail;\r\n        this.tail.prev = this.head;\r\n        return this;\r\n    }\r\n    forEach(cb) {\r\n        for (var it = this.head.next; it !== this.tail; it = it.next) {\r\n            cb(it.a, it.b, it);\r\n        }\r\n        return this;\r\n    }\r\n    union(s) {\r\n        for (var it = s.head.next; it !== s.tail; it = it.next) {\r\n            this.add(it.a, it.b);\r\n        }\r\n        return this;\r\n    }\r\n    contains(a) {\r\n        for (var it = this.head.next; it !== this.tail; it = it.next) {\r\n            if (it.contains(a)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    toString(mapper) {\r\n        var ret = '';\r\n        var t = false;\r\n        for (var it = this.head.next; it !== this.tail; it = it.next) {\r\n            if (t) {\r\n                ret += ',';\r\n            }\r\n            t = true;\r\n            ret += it.toString(mapper);\r\n        }\r\n        return ret === '' ? 'phi' : ret;\r\n    }\r\n}\r\n","map":{"mappings":""}}
