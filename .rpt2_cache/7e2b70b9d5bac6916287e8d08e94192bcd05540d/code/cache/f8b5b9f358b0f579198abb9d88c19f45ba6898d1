{"code":"import { BitSet } from '../util/bitset';\r\nimport { YYTAB } from '../util/common';\r\nimport { CharSet } from './char-set';\r\nexport var Action;\r\n(function (Action) {\r\n    Action[Action[\"START\"] = 0] = \"START\";\r\n    Action[Action[\"END\"] = 1] = \"END\";\r\n    Action[Action[\"NONE\"] = 2] = \"NONE\";\r\n})(Action || (Action = {}));\r\nvar maxlen = 0;\r\nclass StateArray extends Array {\r\n    add(s) {\r\n        for (var i = 0; i < this.length; i++) {\r\n            if (s === this[i]) {\r\n                return;\r\n            }\r\n        }\r\n        this.length > maxlen && (maxlen = this.length);\r\n        this.push(s);\r\n    }\r\n    union(s) {\r\n        for (var i = 0; i < s.length; i++) {\r\n            this.add(s[i]);\r\n        }\r\n    }\r\n    toArray() {\r\n        var ret = [];\r\n        for (let s of this) {\r\n            ret.push(s);\r\n        }\r\n        return ret;\r\n    }\r\n}\r\nexport class Arc {\r\n    constructor(from, to) {\r\n        this.chars = null;\r\n        this.from = from;\r\n        this.to = to;\r\n    }\r\n}\r\nexport class EndAction {\r\n    constructor() {\r\n        this.priority = 0;\r\n        this.id = 0;\r\n        this.data = null;\r\n    }\r\n}\r\nexport class State {\r\n    constructor(endAction) {\r\n        this.valid = false;\r\n        this.arcs = [];\r\n        this.epsilons = [];\r\n        this.index = -1;\r\n        this.isStart = false;\r\n        this.isEnd = false;\r\n        this.endAction = endAction || null;\r\n    }\r\n    findArc(to) {\r\n        for (var i = 0; i < this.arcs.length; i++) {\r\n            if (this.arcs[i].to === to) {\r\n                return this.arcs[i];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    to(s) {\r\n        var arc = this.findArc(s);\r\n        if (arc === null) {\r\n            var arc = new Arc(this, s);\r\n            this.arcs.push(arc);\r\n        }\r\n        s.valid = true;\r\n        return arc;\r\n    }\r\n    epsilonTo(s) {\r\n        this.epsilons.push(s);\r\n    }\r\n    forEach(cb, epOnly) {\r\n        var queue = [this];\r\n        var deja = [];\r\n        epOnly = !!epOnly;\r\n        deja[this.index] = true;\r\n        while (queue.length > 0) {\r\n            var s = queue.pop();\r\n            cb(s);\r\n            if (!epOnly) {\r\n                for (var j = 0; j < s.arcs.length; j++) {\r\n                    var to = s.arcs[j].to;\r\n                    if (!deja[to.index]) {\r\n                        queue.push(to);\r\n                        deja[to.index] = true;\r\n                    }\r\n                }\r\n            }\r\n            for (var j = 0; j < s.epsilons.length; j++) {\r\n                var to = s.epsilons[j];\r\n                if (!deja[to.index]) {\r\n                    queue.push(to);\r\n                    deja[to.index] = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    number() {\r\n        var i = 0;\r\n        this.forEach(function (state) {\r\n            state.index = i++;\r\n        });\r\n    }\r\n    toString(recursive) {\r\n        recursive = !!recursive;\r\n        function single() {\r\n            var ret = 'state ' + this.index;\r\n            if (this.isStart) {\r\n                ret += '(start)';\r\n            }\r\n            if (this.endAction) {\r\n                ret += '(end: ' + this.endAction.id + ')';\r\n            }\r\n            ret += '\\n';\r\n            for (var i = 0; i < this.arcs.length; i++) {\r\n                var arc = this.arcs[i];\r\n                ret += YYTAB + arc.chars.toString() + ' -> state ' + arc.to.index + '\\n';\r\n            }\r\n            if (this.epsilons.length > 0) {\r\n                ret += YYTAB + 'epsilon: ';\r\n                for (var i = 0; i < this.epsilons.length; i++) {\r\n                    if (i > 0) {\r\n                        ret += ',';\r\n                    }\r\n                    ret += this.epsilons[i].index;\r\n                }\r\n                ret += '\\n';\r\n            }\r\n            return ret;\r\n        }\r\n        if (!recursive) {\r\n            return single.call(this);\r\n        }\r\n        else {\r\n            var ret = '';\r\n            this.forEach(function (state) {\r\n                ret += single.call(state) + '\\n';\r\n            });\r\n            return ret;\r\n        }\r\n    }\r\n    copyEndFrom(state) {\r\n        if (state.endAction !== null) {\r\n            if (this.endAction !== null) {\r\n                if (this.endAction.priority < state.endAction.priority) {\r\n                    this.endAction = state.endAction;\r\n                }\r\n            }\r\n            else {\r\n                this.endAction = state.endAction;\r\n            }\r\n        }\r\n    }\r\n    removeEpsilons() {\r\n        var cela = this;\r\n        var valid = [this];\r\n        this.forEach(function (s) {\r\n            if (s.valid) {\r\n                valid.push(s);\r\n            }\r\n        });\r\n        for (var i = 0; i < valid.length; i++) {\r\n            var s = valid[i];\r\n            s.forEach(function (state) {\r\n                if (state !== s) {\r\n                    for (var j = 0; j < state.arcs.length; j++) {\r\n                        var arc = state.arcs[j];\r\n                        s.to(arc.to).chars.union(arc.chars);\r\n                    }\r\n                    s.copyEndFrom(state);\r\n                }\r\n            }, true);\r\n            s.epsilons.length = 0;\r\n        }\r\n        for (var i = 0; i < valid.length; i++) {\r\n            valid[i].index = i;\r\n        }\r\n    }\r\n    count() {\r\n        var c = 0;\r\n        this.forEach(function () {\r\n            c++;\r\n        });\r\n        return c;\r\n    }\r\n    size() {\r\n        var i = 0;\r\n        this.forEach(function () {\r\n            i++;\r\n        });\r\n        return i;\r\n    }\r\n    allChars(set) {\r\n        var cela = this;\r\n        for (var i = 0; i < this.arcs.length; i++) {\r\n            var arc = this.arcs[i];\r\n            arc.chars.forEach(function (a, b) {\r\n                set.add(a, b, arc.to);\r\n            });\r\n        }\r\n    }\r\n    getState(char) {\r\n        for (var i = 0; i < this.arcs.length; i++) {\r\n            var arc = this.arcs[i];\r\n            if (arc.chars.contains(char)) {\r\n                return arc.to;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    hasArc() {\r\n        return this.arcs.length > 0;\r\n    }\r\n    toDFA() {\r\n        var dfaStates = {};\r\n        var states = [];\r\n        var dfaCount = 0;\r\n        var stateCount = this.count();\r\n        var set = new CharSet(() => new StateArray());\r\n        var cela = this;\r\n        var initState = new CompoundState(stateCount, [this]);\r\n        initState.index = dfaCount++;\r\n        states.push(initState);\r\n        var lastState = initState;\r\n        dfaStates[initState.hash()] = initState;\r\n        var queue = [initState];\r\n        while (queue.length > 0) {\r\n            var s = queue.shift();\r\n            set.removeAll();\r\n            s.allChars(set);\r\n            set.forEach(function (chara, charb, it) {\r\n                var cpState = new CompoundState(stateCount, it.dataSet.toArray());\r\n                var cphash = cpState.hash();\r\n                if (dfaStates[cphash]) {\r\n                    cpState = dfaStates[cphash];\r\n                }\r\n                else {\r\n                    dfaStates[cphash] = cpState;\r\n                    queue.push(cpState);\r\n                    cpState.index = dfaCount++;\r\n                    states.push(cpState);\r\n                }\r\n                s.to(cpState).chars.add(chara, charb);\r\n            });\r\n        }\r\n        initState.release();\r\n        return {\r\n            head: initState,\r\n            states: states\r\n        };\r\n    }\r\n}\r\nclass CompoundState extends State {\r\n    constructor(stateCount, states) {\r\n        super();\r\n        this.isEnd = this.isStart = false;\r\n        this.valid = true;\r\n        this.states = states;\r\n        this.stateSet = new BitSet(stateCount);\r\n        for (var i = 0; i < states.length; i++) {\r\n            this.stateSet.add(states[i].index);\r\n            this.copyEndFrom(states[i]);\r\n            this.isStart = this.isStart || states[i].isStart;\r\n        }\r\n    }\r\n    hash() {\r\n        return this.stateSet.hash();\r\n    }\r\n    allChars(set) {\r\n        for (var i = 0; i < this.states.length; i++) {\r\n            this.states[i].allChars(set);\r\n        }\r\n    }\r\n    forEach(cb) {\r\n        super.forEach(cb);\r\n    }\r\n    release() {\r\n        this.forEach(function (state) {\r\n            state.states.length = 0;\r\n        });\r\n    }\r\n}\r\n","map":{"mappings":""}}
