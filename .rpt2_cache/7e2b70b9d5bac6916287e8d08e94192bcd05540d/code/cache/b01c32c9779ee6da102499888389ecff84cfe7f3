{"code":"import { Grammar, Rule } from '../grammar/grammar';\r\nimport { File } from './file';\r\nimport { TokenSet } from '../grammar/token-set';\r\nimport { Assoc } from '../grammar/token-entry';\r\nimport { CompilationError as E } from '../util/E';\r\nexport var RItemType;\r\n(function (RItemType) {\r\n    RItemType[RItemType[\"NAME\"] = 0] = \"NAME\";\r\n    RItemType[RItemType[\"STRING\"] = 1] = \"STRING\";\r\n    RItemType[RItemType[\"BRACKET\"] = 2] = \"BRACKET\";\r\n})(RItemType || (RItemType = {}));\r\n;\r\nexport function GBuilder() {\r\n    var f = new File();\r\n    var g = new Grammar();\r\n    f.grammar = g;\r\n    var tokenCount = 0;\r\n    var tokens = {};\r\n    var rules = [];\r\n    var ruleStack = [];\r\n    var ntCount = 0;\r\n    var nts = {};\r\n    var genIndex = 1;\r\n    var first = true;\r\n    var pr = 1;\r\n    var states = { DEFAULT: 0 };\r\n    var stateCount = 1;\r\n    var stateNum = 0;\r\n    var selectedStates = [];\r\n    var pseudoTokens = {};\r\n    function top() {\r\n        return ruleStack[ruleStack.length - 1];\r\n    }\r\n    function getStateName(num) {\r\n        for (var name in states) {\r\n            if (num === states[name]) {\r\n                return name;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    function splitAction(cela, line) {\r\n        var t = top();\r\n        var s = '@' + genIndex++;\r\n        cela.prepareRule(s);\r\n        cela.addAction(t.action);\r\n        cela.commitRule();\r\n        t.action = null;\r\n        cela.addRuleItem(s, false, line);\r\n    }\r\n    var ret = {\r\n        addToken: function (id, name, line) {\r\n            var tk = tokens[id];\r\n            if (tk) {\r\n                throw new E('token \"' + id + '\"' + ' was already defined at line ' + tk, line);\r\n            }\r\n            else {\r\n                tk = tokens[id] = {\r\n                    index: tokenCount++,\r\n                    name: name,\r\n                    line: line,\r\n                    pr: 0,\r\n                    assoc: Assoc.UNDEFINED,\r\n                };\r\n            }\r\n            return this;\r\n        },\r\n        defineTokenPrec: function (tid, assoc, pseudo, line) {\r\n            if (!pseudo) {\r\n                var t = tokens[tid];\r\n                if (!t) {\r\n                    throw new E('use of undefined token \"' + tid + '\" in associativity defination', line);\r\n                }\r\n                t.assoc = assoc;\r\n                t.pr = pr;\r\n            }\r\n            else {\r\n                var t2 = pseudoTokens[tid] = pseudoTokens[tid] || {\r\n                    assoc: assoc,\r\n                    pr: pr,\r\n                    line: line\r\n                };\r\n            }\r\n            return this;\r\n        },\r\n        setOpt: function (name, value) {\r\n            f.opt[name] = value;\r\n            return this;\r\n        },\r\n        incPr: function () {\r\n            pr++;\r\n            return this;\r\n        },\r\n        changeState: function (s) {\r\n            var sn = states[s];\r\n            if (!sn) {\r\n                sn = states[s] = stateCount++;\r\n            }\r\n            stateNum = sn;\r\n            return this;\r\n        },\r\n        prepareRule: function (lhs, line) {\r\n            if (first) {\r\n                first = false;\r\n                this.prepareRule('(accept)', line);\r\n                this.addRuleItem(lhs, false, line);\r\n                this.commitRule();\r\n            }\r\n            ruleStack.push({\r\n                lhs: lhs,\r\n                action: null,\r\n                rhs: [],\r\n                line: line,\r\n                pr: -1\r\n            });\r\n            if (nts[lhs] === undefined) {\r\n                nts[lhs] = ntCount++;\r\n            }\r\n            return this;\r\n        },\r\n        addRuleItem: function (id, isTerm, line) {\r\n            var t = top();\r\n            if (t.action !== null) {\r\n                splitAction(this, line);\r\n            }\r\n            t.rhs.push({ id: id, isTerm: isTerm, line: line });\r\n            return this;\r\n        },\r\n        addAction: function (b) {\r\n            var t = top();\r\n            if (t.action !== null) {\r\n                splitAction(this, t.line);\r\n            }\r\n            t.action = b;\r\n            return this;\r\n        },\r\n        defineRulePr: function (token, pseudo, line) {\r\n            if (!pseudo) {\r\n                var t = tokens[token];\r\n                if (!t) {\r\n                    throw new E('use of undefined token \"' + token + '\" in rule priority defination', line);\r\n                }\r\n                if (t.assoc === Assoc.UNDEFINED) {\r\n                    throw new E('precedence of token \"' + token + '\" has not been defined', line);\r\n                }\r\n                top().pr = t.pr;\r\n            }\r\n            else {\r\n                var pt = pseudoTokens[token];\r\n                if (!pt) {\r\n                    throw new E('pseudo token \"' + token + '\" is not defined', line);\r\n                }\r\n                top().pr = pt.pr;\r\n            }\r\n            return this;\r\n        },\r\n        commitRule: function () {\r\n            var t = ruleStack.pop();\r\n            rules[t.lhs] || (rules[t.lhs] = []);\r\n            rules.push(t);\r\n            return this;\r\n        },\r\n        build: function () {\r\n            g.tokenCount = tokenCount;\r\n            g.tokens = new Array(tokenCount);\r\n            g.nts = new Array(ntCount);\r\n            for (var tk in tokens) {\r\n                var index = tokens[tk].index;\r\n                g.tokens[index] = {\r\n                    sym: tk,\r\n                    alias: tokens[tk].name,\r\n                    line: tokens[tk].line,\r\n                    pr: tokens[tk].pr,\r\n                    assoc: tokens[tk].assoc,\r\n                    used: false\r\n                };\r\n            }\r\n            for (var nt in nts) {\r\n                g.nts[nts[nt]] = {\r\n                    sym: nt,\r\n                    firstSet: new TokenSet(tokenCount),\r\n                    used: false\r\n                };\r\n            }\r\n            g.tokens[0].used = true;\r\n            g.nts[0].used = true;\r\n            var r = new Array(ntCount);\r\n            var ruleCount = 0;\r\n            for (var i = 0; i < rules.length; i++) {\r\n                var ruleItems = [];\r\n                var rule = rules[i];\r\n                var ntsIndex = nts[rule.lhs];\r\n                r[ntsIndex] || (r[ntsIndex] = []);\r\n                var newRule = new Rule(g, ntsIndex, rule.action, ruleItems, ruleCount++, rule.line);\r\n                newRule.pr = rule.pr;\r\n                r[ntsIndex].push(newRule);\r\n                for (var j = 0; j < rule.rhs.length; j++) {\r\n                    var it = rule.rhs[j];\r\n                    var rulePr = -1;\r\n                    if (it.isTerm) {\r\n                        var tkEntry = tokens[it.id];\r\n                        if (tkEntry === undefined) {\r\n                            throw new E('use of undefined token \"' + it.id + '\"', it.line);\r\n                        }\r\n                        var termIndex = tkEntry.index;\r\n                        ruleItems.push(tkEntry.index);\r\n                        g.tokens[termIndex].used = true;\r\n                        if (tkEntry.assoc !== Assoc.UNDEFINED) {\r\n                            rulePr = tkEntry.pr;\r\n                        }\r\n                    }\r\n                    else {\r\n                        var ntIndex = nts[it.id];\r\n                        if (ntIndex === undefined) {\r\n                            throw new E('use of undefined non terminal \"' + it.id + '\"', it.line);\r\n                        }\r\n                        ruleItems.push(ntIndex + tokenCount);\r\n                        g.nts[ntIndex].used = true;\r\n                    }\r\n                    if (newRule.pr === -1 && rulePr !== -1) {\r\n                        newRule.pr = rulePr;\r\n                    }\r\n                }\r\n            }\r\n            g.rules = r;\r\n            return f;\r\n        }\r\n    };\r\n    ret.addToken('eof', '', 1);\r\n    return ret;\r\n}\r\n","map":{"mappings":""}}
