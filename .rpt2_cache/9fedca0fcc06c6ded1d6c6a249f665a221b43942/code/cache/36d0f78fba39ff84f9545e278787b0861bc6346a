{"code":"import { GBuilder } from './gbuilder';\r\nimport { Assoc } from '../grammar/token-entry';\r\nimport { CompilationError as E } from '../util/E';\r\nvar T = {\r\n    EOF: 0,\r\n    NAME: 1,\r\n    STRING: 2,\r\n    TOKEN_DIR: 3,\r\n    OPT: 4,\r\n    BLOCK: 5,\r\n    ARROW: 6,\r\n    EOL: 7,\r\n    OR: 8,\r\n    TOKEN: 9,\r\n    SEPERATOR: 10,\r\n    LEFT_DIR: 11,\r\n    RIGHT_DIR: 12,\r\n    NONASSOC_DIR: 13,\r\n    PREC_DIR: 14,\r\n    REGEXP: 15,\r\n    STATE_DIR: 16,\r\n    LINE_COMMENT: 17,\r\n    BLOCK_COMMENT: 18,\r\n    OPEN_CURLY_BRA: 19,\r\n    CLOSE_CURLY_BRA: 20\r\n};\r\nvar tokenNames = [];\r\nfor (var tname in T) {\r\n    tokenNames[T[tname]] = tname;\r\n}\r\nfunction Token() {\r\n    this.id = T.EOF;\r\n    this.line = 0;\r\n    this.val = null;\r\n    this.img = null;\r\n}\r\nToken.prototype.clone = function () {\r\n    var t = new Token();\r\n    t.id = this.id;\r\n    t.line = this.line;\r\n    t.img = this.img;\r\n    t.val = this.val;\r\n    return t;\r\n};\r\nfunction scan(opt) {\r\n    if (opt === void 0) { opt = {}; }\r\n    var highlight = !!opt.isHighlight;\r\n    var collectImg = false;\r\n    var line = 1;\r\n    var img = null;\r\n    var stream = null;\r\n    var c = null;\r\n    function eof() {\r\n        return c === null;\r\n    }\r\n    function isBlank(c) {\r\n        return c == ' ' || c == '\\n' || c == '\\t';\r\n    }\r\n    function nc() {\r\n        if (collectImg) {\r\n            img += c;\r\n        }\r\n        if (c === '\\n') {\r\n            line++;\r\n        }\r\n        stream.next();\r\n        c = stream.peek();\r\n    }\r\n    function err(c1) {\r\n        var s1 = '';\r\n        if (eof()) {\r\n            s1 = 'unexpected end of file';\r\n        }\r\n        else {\r\n            s1 = 'unexpected character \"' + c + '\"';\r\n        }\r\n        if (c1) {\r\n            throw new E(s1 + ' after \"' + c1 + '\"', line);\r\n        }\r\n        else {\r\n            throw new E(s1, line);\r\n        }\r\n    }\r\n    function iss(s) {\r\n        var ii = 0;\r\n        while (ii < s.length) {\r\n            if (s.charAt(ii++) !== c) {\r\n                return false;\r\n            }\r\n            nc();\r\n        }\r\n        return true;\r\n    }\r\n    var escapes = {\r\n        'n': '\\n',\r\n        't': '\\t'\r\n    };\r\n    function escapeChar(regexp) {\r\n        var tc = c;\r\n        if (eof()) {\r\n            return '';\r\n        }\r\n        nc();\r\n        var ret = escapes[tc];\r\n        if (ret !== undefined) {\r\n            return ret;\r\n        }\r\n        else {\r\n            if (regexp) {\r\n                return '\\\\' + tc;\r\n            }\r\n            else {\r\n                if (tc === '\\\\') {\r\n                    return '\\\\';\r\n                }\r\n                else {\r\n                    return '\\\\' + tc;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function handleString() {\r\n        var eos = c;\r\n        var ret = '';\r\n        nc();\r\n        while (c != eos) {\r\n            if (eof()) {\r\n                throw new E('unterminated string literal', line);\r\n            }\r\n            else if (c === '\\\\') {\r\n                nc();\r\n                ret += escapeChar(false);\r\n            }\r\n            else {\r\n                ret += c;\r\n                nc();\r\n            }\r\n        }\r\n        nc();\r\n        return ret;\r\n    }\r\n    function handleRegExp() {\r\n        var ret = '';\r\n        while (c !== '/') {\r\n            if (eof()) {\r\n                throw new E('unterminated regular expression literal', line);\r\n            }\r\n            else if (c === '\\\\') {\r\n                nc();\r\n                ret += escapeChar(true);\r\n            }\r\n            else {\r\n                ret += c;\r\n                nc();\r\n            }\r\n        }\r\n        nc();\r\n        return ret;\r\n    }\r\n    function next(token) {\r\n        token.val = null;\r\n        while (isBlank(c) && !eof()) {\r\n            nc();\r\n        }\r\n        token.line = line;\r\n        token.img = img = '';\r\n        if (eof()) {\r\n            token.id = T.EOF;\r\n            return token;\r\n        }\r\n        lex: switch (c) {\r\n            case '%':\r\n                nc();\r\n                if (iss('token')) {\r\n                    token.id = T.TOKEN_DIR;\r\n                    break lex;\r\n                }\r\n                else if (iss('opt')) {\r\n                    token.id = T.OPT;\r\n                    break lex;\r\n                }\r\n                else if (iss('left')) {\r\n                    token.id = T.LEFT_DIR;\r\n                    break lex;\r\n                }\r\n                else if (iss('right')) {\r\n                    token.id = T.RIGHT_DIR;\r\n                    break lex;\r\n                }\r\n                else if (iss('nonassoc')) {\r\n                    token.id = T.NONASSOC_DIR;\r\n                    break lex;\r\n                }\r\n                else if (iss('prec')) {\r\n                    token.id = T.PREC_DIR;\r\n                    break lex;\r\n                }\r\n                else if (iss('state')) {\r\n                    token.id = T.STATE_DIR;\r\n                    break lex;\r\n                }\r\n                else if (c == '%') {\r\n                    nc();\r\n                    token.id = T.SEPERATOR;\r\n                    break lex;\r\n                }\r\n                err('%');\r\n            case '{':\r\n                nc();\r\n                if (highlight) {\r\n                    token.id = T.OPEN_CURLY_BRA;\r\n                    break lex;\r\n                }\r\n                else {\r\n                    token.id = T.BLOCK;\r\n                    token.val = '';\r\n                    var st = 1;\r\n                    while (st > 0) {\r\n                        if (eof()) {\r\n                            throw new E('unclosed block', line);\r\n                        }\r\n                        if (c == '{') {\r\n                            st++;\r\n                        }\r\n                        else if (c == '}') {\r\n                            st--;\r\n                        }\r\n                        token.val += c;\r\n                        nc();\r\n                    }\r\n                    break lex;\r\n                }\r\n            case '/':\r\n                nc();\r\n                if (c === '/') {\r\n                    nc();\r\n                    token.val = '//';\r\n                    while (c !== '\\n' && !eof()) {\r\n                        token.val += c;\r\n                        nc();\r\n                    }\r\n                    token.id = T.LINE_COMMENT;\r\n                    break lex;\r\n                }\r\n                else if (c === '*') {\r\n                    nc();\r\n                    token.val = '/*';\r\n                    while (!eof()) {\r\n                        if (c === '*') {\r\n                            nc();\r\n                            if (c === '/') {\r\n                                nc();\r\n                                break;\r\n                            }\r\n                            else if (eof()) {\r\n                                break;\r\n                            }\r\n                            else {\r\n                                token.val += '*';\r\n                            }\r\n                        }\r\n                        else {\r\n                            token.val += c;\r\n                            nc();\r\n                        }\r\n                    }\r\n                    token.id = T.BLOCK_COMMENT;\r\n                    break lex;\r\n                }\r\n                else {\r\n                    token.id = T.REGEXP;\r\n                    token.val = handleRegExp();\r\n                    break lex;\r\n                }\r\n            case '|':\r\n                nc();\r\n                token.id = T.OR;\r\n                break lex;\r\n            case ';':\r\n                nc();\r\n                token.id = T.EOL;\r\n                break lex;\r\n            case ':':\r\n                nc();\r\n                token.id = T.ARROW;\r\n                break lex;\r\n            case '-':\r\n                nc();\r\n                if (c == '>') {\r\n                    nc();\r\n                    token.id = T.ARROW;\r\n                    break lex;\r\n                }\r\n                err('-');\r\n            case '\\'':\r\n            case '\"':\r\n                token.id = T.STRING;\r\n                token.val = handleString();\r\n                break lex;\r\n            case '<':\r\n                nc();\r\n                token.id = T.TOKEN;\r\n                token.val = '';\r\n                while (c !== '>' && !eof()) {\r\n                    token.val += c;\r\n                    nc();\r\n                }\r\n                if (eof()) {\r\n                    throw new E('unexpected end of file: incomplete token literal', line);\r\n                }\r\n                nc();\r\n                if (token.val === '') {\r\n                    throw new E('unexpected empty token', line);\r\n                }\r\n                break lex;\r\n            default:\r\n                if (/[A-Za-z_$]/.test(c)) {\r\n                    token.id = T.NAME;\r\n                    token.val = c;\r\n                    nc();\r\n                    while (/[A-Za-z0-9_$]/.test(c) && !eof()) {\r\n                        token.val += c;\r\n                        nc();\r\n                    }\r\n                    break lex;\r\n                }\r\n                nc();\r\n                err();\r\n        }\r\n        ;\r\n        if (collectImg) {\r\n            token.img = img;\r\n            return token;\r\n        }\r\n    }\r\n    ;\r\n    return {\r\n        next: next,\r\n        init: function (s) {\r\n            stream = s;\r\n            c = s.peek();\r\n        }\r\n    };\r\n}\r\nfunction parse(scanner) {\r\n    var token = new Token();\r\n    var gb = new GBuilder();\r\n    function nt() {\r\n        scanner.next(token);\r\n    }\r\n    function expect(id) {\r\n        if (token.id !== id) {\r\n            throw new E('unexpected token \"' + tokenNames[token.id] + '\",expecting \"' + tokenNames[id] + '\"', token.line);\r\n        }\r\n        nt();\r\n    }\r\n    function file() {\r\n        options();\r\n        expect(T.SEPERATOR);\r\n        rules();\r\n        expect(T.EOF);\r\n    }\r\n    function prTokens(assoc) {\r\n        do {\r\n            if (token.id === T.STRING) {\r\n                gb.defineTokenPrec(token.val, assoc, false, token.line);\r\n            }\r\n            else if (token.id === T.NAME) {\r\n                gb.defineTokenPrec(token.val, assoc, true, token.line);\r\n            }\r\n            else {\r\n                throw new E('unexpected token \"' + tokenNames[token.id] + '\",expecting string or name', token.line);\r\n            }\r\n            nt();\r\n        } while (token.id === T.STRING || token.id === T.NAME);\r\n        gb.incPr();\r\n    }\r\n    function options() {\r\n        while (1) {\r\n            switch (token.id) {\r\n                case T.TOKEN_DIR:\r\n                    nt();\r\n                    do {\r\n                        tokenDef();\r\n                    } while (token.id === T.STRING);\r\n                    break;\r\n                case T.LEFT_DIR:\r\n                    nt();\r\n                    prTokens(Assoc.LEFT);\r\n                    break;\r\n                case T.RIGHT_DIR:\r\n                    nt();\r\n                    prTokens(Assoc.RIGHT);\r\n                    break;\r\n                case T.NONASSOC_DIR:\r\n                    nt();\r\n                    prTokens(Assoc.NON);\r\n                    break;\r\n                case T.OPT:\r\n                    nt();\r\n                    var name = token.val;\r\n                    expect(T.NAME);\r\n                    var s = token.val;\r\n                    expect(T.STRING);\r\n                    gb.setOpt(name, s);\r\n                    break;\r\n                case T.STATE_DIR:\r\n                    nt();\r\n                    var n = token.val;\r\n                    expect(T.NAME);\r\n                    gb.changeState(n);\r\n                    break;\r\n                default: return;\r\n            }\r\n        }\r\n    }\r\n    function tokenDef() {\r\n        var name = token.val;\r\n        var alias = null;\r\n        var tline = token.line;\r\n        if (token.id !== T.STRING && token.id !== T.TOKEN) {\r\n            throw new E('unexpeted token \"' + tokenNames[token.id] + '\",expecting STRING or TOKEN', token.line);\r\n        }\r\n        nt();\r\n        if (token.id === T.NAME) {\r\n            alias = token.val;\r\n            nt();\r\n        }\r\n        gb.addToken(name, alias, tline);\r\n    }\r\n    function rules() {\r\n        rule();\r\n        while (token.id !== T.SEPERATOR) {\r\n            rule();\r\n        }\r\n        nt();\r\n    }\r\n    function rule() {\r\n        var lhs = token.clone();\r\n        expect(T.NAME);\r\n        expect(T.ARROW);\r\n        gb.prepareRule(lhs.val, lhs.line);\r\n        ruleItems();\r\n        gb.commitRule();\r\n        while (token.id === T.OR) {\r\n            nt();\r\n            gb.prepareRule(lhs.val, lhs.line);\r\n            ruleItems();\r\n            gb.commitRule();\r\n        }\r\n        expect(T.EOL);\r\n    }\r\n    function ruleItems() {\r\n        while (token.id === T.NAME || token.id === T.TOKEN || token.id === T.STRING || token.id === T.BLOCK) {\r\n            var t = token.clone();\r\n            if (token.id === T.NAME) {\r\n                nt();\r\n                gb.addRuleItem(t.val, false, t.line);\r\n            }\r\n            else if (token.id === T.STRING || token.id === T.TOKEN) {\r\n                nt();\r\n                gb.addRuleItem(t.val, true, t.line);\r\n            }\r\n            if (token.id === T.BLOCK) {\r\n                gb.addAction(token.val);\r\n                nt();\r\n            }\r\n        }\r\n        if (token.id === T.PREC_DIR) {\r\n            nt();\r\n            var t = token.val;\r\n            var line = token.line;\r\n            if (token.id === T.STRING) {\r\n                gb.defineRulePr(t, false, line);\r\n                nt();\r\n            }\r\n            else if (token.id === T.NAME) {\r\n                gb.defineRulePr(t, true, line);\r\n                nt();\r\n            }\r\n            else {\r\n                throw new E('unexpected token \"' + tokenNames[token.id] + '\",expecting string or name', token.line);\r\n            }\r\n            if (token.id === T.BLOCK) {\r\n                gb.addAction(token.val);\r\n                nt();\r\n            }\r\n        }\r\n    }\r\n    nt();\r\n    file();\r\n    return gb.build();\r\n}\r\nfunction commentFilter(scanner) {\r\n    return {\r\n        next: function (token) {\r\n            do {\r\n                scanner.next(token);\r\n            } while (token.id === T.BLOCK_COMMENT || token.id === T.LINE_COMMENT);\r\n        },\r\n        init: function (s) {\r\n            scanner.init(s);\r\n        }\r\n    };\r\n}\r\nvar highlightUtil = {\r\n    T: T,\r\n    Token: Token,\r\n    scanner: scan\r\n};\r\nfunction parseSource(source) {\r\n    var scanner = scan();\r\n    scanner.init(source);\r\n    return parse(commentFilter(scanner));\r\n}\r\nexport { highlightUtil, parseSource };\r\n","map":{"mappings":""}}
