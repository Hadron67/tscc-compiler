/*
    generated by jscc, an LALR(1) parser generator made by hadroncfy
*/
<%
let prefix = input.prefix;
let tab = input.opt.tab || '    ';
function echo(s: string){
    output.write(s);
}
function writeln(s: string){
    output.writeln(s);
}
function leftAlign(s: string, al: number): string{
    function repeat(s: string, t: number){
        let ret = '';
        while(t --> 0) ret += s;
        return ret;
    }
    return (s.length < al ? repeat(' ', al - s.length) : '') + s;
}
function printTable<T>(tname: string, t: T[], nl: number, mapper: (d: T) => string){
    let count = 0; %>
let <%- prefix + tname %> = [ 
    <% for(let i of t){
        echo(leftAlign(mapper(i), nl));
        echo(',');
        count++ > 6 && (count = 0, echo(input.endl + tab));
    } %>
]; 
<% } %>

<% function printState(state: State<LexAction[]>){ 
    function arcToString(arc: Arc<LexAction[]>): string{
        let ret: string[] = [];
        arc.chars.forEach((from, to) => {
            let s: string[] = [];
            from !== Inf._oo && s.push(`c >= ${from}`);
            to !== Inf.oo && s.push(`c <= ${to}`);
            ret.push(s.join(' && '));
        });
        return ret.join(' || ');
    } 
    let first = true; %>
    case <%- state.index.toString() %>:
        ret.nfa = <%- state.arcs.length > 0 && state.endAction !== null ? 'true' : 'false' %>;
        ret.isEnd = <%- state.endAction === null ? 'false' : 'true' %>;
    <% for(let arc of state.arcs){
        if(first) { %>
        if(<%- arcToString(arc) %>){
            ret.state = <%- arc.to.index.toString() %>;
        }
        <% first = false;
        } else { %>
        else if(<%- arcToString(arc) %>){
            ret.state = <%- arc.to.index.toString() %>;
        }
        <% }
    } 
    if(state.arcs.length === 0) { %>
        ret.state = -1;
    <% } else { %>
        else {
            ret.state = -1;
        }
    <% } %>
        break;
<% } %>

<% function printDFA(dfa: DFA<LexAction[]>, n: number){ %>
function moveDFA<%- n.toString() %>(c: number, ret: { state: number, nfa: boolean, isEnd: boolean }){
    switch(ret.state){
        <% for(let state of dfa.states){
            printState(state);
        } %>
        default:
            ret.state = -1;
            ret.nfa = false;
    }
}
<% } %>

/*
    find the next state to go in the dfa
*/
<% for(let i = 0, _a = input.dfas; i < _a.length; i++){
    printDFA(_a[i], i);
} %>

/*
    all the lexer data goes here.
*/
let <%- prefix %>lexers = [
    <% for(let i = 0;i < input.dfas.length;i++){ %>
    moveDFA<%- i.toString() %>,
    <% } %>
];

<% let pt = input.pt; %>
let <%- prefix %>stateCount = <%- pt.stateCount.toString() %>;
/*
    compressed action table: action = <%- prefix %>pact[<%- prefix %>disact[STATE-NUM] + TOKEN]
    when action > 0, shift the token and goto state (action - 1);
    when action < 0, reduce with rule (1-action);
    when action = 0, do default action.
*/
<% printTable<Item>('pact', pt.pact, 6, t => {
    if(t === null || t === Item.NULL){
        return '0';
    }
    else if(t.actionType === Action.SHIFT){
        return (t.shift.stateIndex + 1).toString();
    }
    else if(t.actionType === Action.REDUCE){
        return (-t.rule.index - 1).toString();
    }
}); %>
/*
    displacement of action table.
*/
<% printTable<number>('disact', pt.disact, 6, t => t.toString()); %>
/*
    used to check if a position in <%- prefix  %>pact is out of bouds.
    if <%- prefix  %>checkact[<%- prefix %>disact[STATE-NUM] + TOKEN] = STATE-NUM, this position is not out of bounds.
*/
<% printTable<number>('checkact', pt.checkact, 6, t => t === undefined ? '0' : t.toString()); %>
/*
    default action table. action = <%- prefix %>defred[STATE-NUM],
    where action is the number of the rule to reduce with.
*/
<% printTable<number>('defred', pt.defred, 6, t => t.toString()); %>
/*
    compressed goto table: goto = <%- prefix  %>pgoto[<%- prefix %>disgoto[STATE-NUM] + NON_TERMINAL]
*/
<% printTable<Item>('pgoto', pt.pgoto, 6, t => {
    if(t === null){
        return '-1';
    }
    else {
        return t.shift.stateIndex.toString();
    }
}); %>
/*
    displacement of the goto table
*/
<% printTable<number>('disgoto', pt.disgoto, 6, t => t.toString()); %>
/*
    length of each rule: rule length = <%- prefix %>ruleLen[RULE-NUM]
*/
<% printTable<Rule>('ruleLen', pt.g.rules, 6, r => r.rhs.length.toString()); %>
/*
    index of the LHS of each rule
*/
<% printTable<Rule>('lhs', pt.g.rules, 6, r => r.lhs.index.toString()); %>
/*
    token names
*/
<% printTable<TokenDef>('tokenNames', pt.g.tokens, 6, t => `"${t.sym}"`); %>
/*
    token alias
*/
<% printTable<TokenDef>('tokenAlias', pt.g.tokens, 6, t => `"${t.alias}"` || '""'); %>
<% let className = input.opt.className || 'Parser'; %>

<% function printLexActionsFunc(dfa: DFA<LexAction[]>, n: number){
    let codegen = {
        addBlock(b: string, line: number){ %>
                <%- b %>
        <% },
        pushLexState(n: number){ %>
                this._lexState.push(<%- n.toString() %>);
        <% },
        popLexState(){ %>
                this._lexState.pop();
        <% },
        setImg(n: string){ %>
                this._setImg("<%- n %>");
        <% },
        returnToken(t: TokenDef){ %>
                this._token = {
                    id: <%- t.index.toString() %>,
                    val: this._matched.join('')
                };
        <% }
    }; 
    let statevn = prefix + 'staten'; %>
    private _doLexAction<%- n.toString() %>(<%- statevn %>: number){
        switch(<%- statevn %>){
            <% for(let i = 0, _a = dfa.states; i < _a.length; i++){ 
                if(_a[i].endAction !== null){ %>
            case <%- i.toString() %>:
                    <% for(let act of _a[i].endAction.data){
                        act(codegen);
                    } %>
                break;
                <% } %>
            <% } %>
            default:;
        }
    }
<% } %>

interface Token{
    id: number;
    val: string;
};

export class <%- className %> {
    // members for lexer
    private _lexState: number[] = [];
    private _state: number = 0;
    private _matched: string[] = [];
    private _token: Token = null;
    private _marker: number = -1;
    private _backup: string[] = [];

    // members for parser
    private _lrState: number[] = [];
    private _sematicS: <%- input.sematicType %>[] = [];

    private _setImg(s: string){
        this._matched.length = 0;
        for(let i = 0;i < s.length;i++){
            this._matched.push(s.charAt(i));
        }
    }
    <% for(let i = 0, _a = input.dfas; i < _a.length; i++){
        printLexActionsFunc(_a[i], i);
    } %>
    <% let lexstatevn = prefix + 'lexstate'; %>
    private _doLexAction(<%- lexstatevn %>: number, <%- prefix %>state: number){
        switch(<%- lexstatevn %>){
            <% for(let i = 0;i < input.dfas.length;i++){ %>
            case <%- i.toString() %>:
                this._doLexAction<%- i.toString() %>(<%- prefix %>state);
                break;
            <% } %>
            default:;
        }
    }
    private _acceptChar(c: number){
        let lexstate = this._lexState[this._lexState.length - 1];
        this._marker && this._backup.push(c);
        let retn = { state: this._state, nfa: false, isEnd: false };
        <%- prefix %>lexers[lexstate](c, retn);
        if(retn.isEnd){

        }
    }
}
