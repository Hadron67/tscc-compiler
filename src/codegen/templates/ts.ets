/*
    generated by jscc, an LALR(1) parser generator made by hadroncfy.
    template for typescript, written by hadroncfy, aussi.
*/
<%- input.header %>
<%
let prefix = input.prefix;
let tab = input.opt.tab || '    ';
function echo(s: string | number){
    output.write(s);
}
function echoLine(s: string | number){
    output.writeln(s);
}
function leftAlign(s: string, al: number): string{
    function repeat(s: string, t: number){
        let ret = '';
        while(t --> 0) ret += s;
        return ret;
    }
    return (s.length < al ? repeat(' ', al - s.length) : '') + s;
}
function printTable<T>(tname: string, t: T[], align: number, lc: number, mapper: (d: T) => string){
    let count = 1; %>
let <%- prefix + tname %> = [ 

    <% echo(tab); %>
    <% for(let i of t){
        echo(leftAlign(mapper(i), align));
        echo(',');
        count++ >= lc && (count = 1, echo(input.endl + tab));
    } %>
]; 
<% } 
function printState(state: State<LexAction[]>){ 
    function arcToString(arc: Arc<LexAction[]>): string{
        let ret: string[] = [];
        arc.chars.forEach((from, to) => {
            if(from === to){
                ret.push(`c === ${from}`);
            }
            else if(from === 0 && to !== Inf.oo){
                ret.push(`c <= ${to}`);
            }
            else if(from !== 0 && to === Inf.oo){
                ret.push(`c >= ${from}`);
            }
            else if(from !== 0 && to !== Inf.oo){
                ret.push(`(c >= ${from} && c <= ${to})`);
            }
            else {
                // this merely happens
                ret.push('true');
            }
        });
        return ret.join(' || ');
    } 
    let first = true; %>
        case <%- state.index.toString() %>:
            ret.hasArc = <%- state.arcs.length > 0 ? 'true' : 'false' %>;
            ret.isEnd = <%- state.endAction === null ? 'false' : 'true' %>;
    <% for(let arc of state.arcs){
        if(first) { %>
            if(<%- arcToString(arc) %>){
                ret.state = <%- arc.to.index.toString() %>;
            }
        <% first = false;
        } else { %>
            else if(<%- arcToString(arc) %>){
                ret.state = <%- arc.to.index.toString() %>;
            }
        <% }
    } 
    if(state.arcs.length === 0) { %>
            ret.state = -1;
    <% } else { %>
            else {
                ret.state = -1;
            }
    <% } %>
            break;
<% } 
function printDFA(dfa: DFA<LexAction[]>, n: number){ %>
function moveDFA<%- n.toString() %>(c: number, ret: { state: number, hasArc: boolean, isEnd: boolean }){
    switch(ret.state){
        <% for(let state of dfa.states){
            printState(state);
        } %>
        default:
            ret.state = -1;
            ret.hasArc = false;
    }
}
<% }
function printLexTokens(dfa: DFA<LexAction[]>, n: number){
    function getAction(act: LexAction[]): number{
        for(let a of act){
            if(a.token !== -1){
                return a.token;
            }
        }
        return -1;
    }
    printTable<State<LexAction[]>>('lexTokens' + n, dfa.states, 6, 10, (state) => {
        return state.endAction ? getAction(state.endAction.data).toString() : '-1';
    });
} %>

/*
    find the next state to go in the dfa
*/
<% for(let i = 0, _a = input.dfas; i < _a.length; i++){
    printDFA(_a[i], i);
} %>

/*
    all the lexer data goes here.
*/
let <%- prefix %>lexers = [
<% for(let i = 0;i < input.dfas.length;i++){ %>
    moveDFA<%- i.toString() %>,
<% } %>
];

/*
    tokens that a lexical dfa state can return
*/
<% for(let i = 0, _a = input.dfas; i < _a.length; i++){
    printLexTokens(_a[i], i);
} %>

<% let pt = input.pt; %>
let <%- prefix %>stateCount = <%- pt.stateCount.toString() %>;
/*
    compressed action table: action = <%- prefix %>pact[<%- prefix %>disact[STATE-NUM] + TOKEN]
    when action > 0, shift the token and goto state (action - 1);
    when action < 0, reduce with rule (1-action);
    when action = 0, do default action.
*/
<% printTable<Item>('pact', pt.pact, 6, 10, t => {
    if(t === null || t === Item.NULL){
        return '0';
    }
    else if(t.actionType === Action.SHIFT){
        return (t.shift.stateIndex + 1).toString();
    }
    else if(t.actionType === Action.REDUCE){
        return (-t.rule.index - 1).toString();
    }
}); %>
/*
    displacement of action table.
*/
<% printTable<number>('disact', pt.disact, 6, 10, t => t.toString()); %>
/*
    used to check if a position in <%- prefix  %>pact is out of bouds.
    if <%- prefix  %>checkact[<%- prefix %>disact[STATE-NUM] + TOKEN] = STATE-NUM, this position is not out of bounds.
*/
<% printTable<number>('checkact', pt.checkact, 6, 10, t => t === undefined ? '0' : t.toString()); %>
/*
    default action table. action = <%- prefix %>defred[STATE-NUM],
    where action is the number of the rule to reduce with.
*/
<% printTable<number>('defred', pt.defred, 6, 10, t => t.toString()); %>
/*
    compressed goto table: goto = <%- prefix  %>pgoto[<%- prefix %>disgoto[STATE-NUM] + NON_TERMINAL]
*/
<% printTable<Item>('pgoto', pt.pgoto, 6, 10, t => {
    if(t === null){
        return '-1';
    }
    else {
        return t.shift.stateIndex.toString();
    }
}); %>
/*
    displacement of the goto table
*/
<% printTable<number>('disgoto', pt.disgoto, 6, 10, t => t.toString()); %>
/*
    length of each rule: rule length = <%- prefix %>ruleLen[RULE-NUM]
*/
<% printTable<Rule>('ruleLen', pt.g.rules, 6, 10, r => r.rhs.length.toString()); %>
/*
    index of the LHS of each rule
*/
<% printTable<Rule>('lhs', pt.g.rules, 6, 10, r => r.lhs.index.toString()); %>
/*
    token names
*/
<% printTable<TokenDef>('tokenNames', pt.g.tokens, 20, 3, t => `"${t.sym}"`); %>
/*
    token alias
*/
<% printTable<TokenDef>('tokenAlias', pt.g.tokens, 20, 3, t => `"${t.alias}"` || '""'); %>
<% let className = input.opt.className || 'Parser'; %>

<% function printLexActionsFunc(dfa: DFA<LexAction[]>, n: number){
    let codegen = {
        addBlock(b: string, line: number){ %>
                <%- b %>
        <% },
        pushLexState(n: number){ %>
                this._lexState.push(<%- n.toString() %>);
        <% },
        popLexState(){ %>
                this._lexState.pop();
        <% },
        setImg(n: string){ %>
                this._setImg("<%- n %>");
        <% },
        returnToken(t: TokenDef){ %>
                this._token = {
                    id: <%- t.index.toString() %>,
                    val: this._matched.join('')
                };
        <% }
    }; 
    function hasNormalAction(a: LexAction[]){
        for(let act of a){
            if(act.token === -1){
                return true;
            }
        }
        return false;
    }
    let statevn = prefix + 'staten'; %>
    private _doLexAction<%- n.toString() %>(<%- statevn %>: number){
        let <%- prefix %>tk = <%- prefix %>lexTokens<%- n.toString() %>[<%- statevn %>];
        switch(<%- statevn %>){
            <% for(let i = 0, _a = dfa.states; i < _a.length; i++){ 
                if(_a[i].endAction !== null && hasNormalAction(_a[i].endAction.data)){ %>
            case <%- i.toString() %>:
                    <% for(let act of _a[i].endAction.data){
                        act.token === -1 && act.toCode(codegen);
                    } %>
                break;
                <% }
            } %>
            default:;
        }
        <%- prefix %>tk !== -1 && this._returnToken(<%- prefix %>tk);
    }
<% } %>

interface Token{
    id: number;
    val: string;

    startLine: number;
    startColumn: number;
    endLine: number;
    endColumn: number;
};

export class <%- className %> {
    // members for lexer
    private _lexState: number[] = [];
    private _state: number = 0;
    private _matched: string[] = [];
    private _token: Token = null;
    private _marker: number = -1;
    private _markerLine = 0;
    private _markerColumn = 0;
    private _backupCount: number = 0;
    private _inputBuf: string[] = [];
    private _line = 0;
    private _column = 0;
    private _tline = 0;
    private _tcolumn = 0;

    // members for parser
    private _lrState: number[] = [];
    private _sematicS: any[] = [];
    private _accepted = false;

    private _handlers: {[s: string]: ((a1?, a2?, a3?) => any)[]} = {};

    // extra members, defined by %extra_arg
    <%- input.extraArg %>

    init(){
        this._lexState = [];
        this._state = 0;
        this._matched = [];
        this._token = null;
        this._marker = -1;
        this._markerLine = this._markerColumn = 0;
        this._backupCount = 0;
        this._inputBuf = [];
        this._line = this._tline = 0;
        this._column = this._tcolumn = 0;
        
        this._lrState = [];
        this._sematicS = [];
        this._accepted = false;

        this._handlers = {};
    }
    /**
     *  set 
     */
    private _setImg(s: string){
        this._matched.length = 0;
        for(let i = 0;i < s.length;i++){
            this._matched.push(s.charAt(i));
        }
        this._tline = this._line;
        this._tcolumn = this._column;
    }
    private _returnToken(tid: number){
        this._token = {
            id: tid,
            val: this._matched.join(''),
            startLine: this._tline,
            startColumn: this._tcolumn,
            endLine: this._line,
            endColumn: this._column
        }
        this._matched.length = 0;
        this._tline = this._line;
        this._tcolumn = this._column;
        this._emit('token', this._token);
        while(!this._acceptToken(this._token));
        this._token = null;
    }
    private _emit(name: string, a1?, a2?, a3?){
        let cbs = this._handlers[name];
        if(cbs){
            for(let cb of cbs){
                cb(a1, a2, a3);
            }
        }
    }
    on(name: string, cb: (a1?, a2?, a3?) => any){
        this._handlers[name] || (this._handlers[name] = []);
        this._handlers[name].push(cb);
    }
<% for(let i = 0, _a = input.dfas; i < _a.length; i++){
    printLexActionsFunc(_a[i], i);
} %>
    /**
     *  do a lexical action
     *  @api private
     *  @internal
     */
    private _doLexAction(lexstate: number, state: number){
        switch(lexstate){
<% for(let i = 0;i < input.dfas.length;i++){ %>
            case <%- i.toString() %>:
                this._doLexAction<%- i.toString() %>(state);
                break;
<% } %>
            default:;
        }
        this._token !== null && (this._acceptToken(this._token), (this._token = null));
    }
    private _acceptChar(c: string){
        let lexstate = this._lexState[this._lexState.length - 1];
        let retn = { state: this._state, hasArc: false, isEnd: false };
        <%- prefix %>lexers[lexstate](c.charCodeAt(0), retn);
        if(retn.isEnd){
            // if current state is a terminate state, be careful
            if(retn.hasArc){
                if(retn.state === -1){
                    // nowhere to go, stay where we are
                    this._doLexAction(lexstate, this._state);
                    // recover
                    this._marker = -1;
                    this._backupCount = 0;
                    this._state = 0;                    
                    // character not consumed
                    return false;
                }
                else {
                    // now we can either go to that new state, or stay where we are
                    // it is prefered to move forward, but that could lead to errors,
                    // so we need to memorize this state before move on, in case if 
                    // an error occurs later, we could just return to this state.
                    this._marker = this._state;
                    this._markerLine = this._line;
                    this._markerColumn = this._column;
                    this._state = retn.state;
                    this._backupCount = 1;
                    this._matched.push(c);
                    c === '\n' ? (this._line++, this._column = 0) : (this._column++);
                    // character consumed
                    return true;
                }
            }
            else {
                // current state doesn't lead to any state, just stay here.
                this._doLexAction(lexstate, this._state);
                // recover
                this._marker = -1;
                this._backupCount = 0;
                this._state = 0;
                // character not consumed
                return false;
            }
        }
        else {
            if(retn.state === -1){
                // nowhere to go at current state, error may have occured.
                // check marker to verify that
                if(this._marker !== -1){
                    // we have a previously marked state, which is a terminate state.
                    // rollback
                    this._state = this._marker;
                    this._marker = -1;
                    this._line = this._markerLine;
                    this._column = this._markerColumn;
                    while(this._backupCount --> 0){
                        this._inputBuf.push(this._matched.pop());
                    }
                    this._doLexAction(lexstate, this._state);
                    this._state = 0;
                    // character not consumed
                    return false;
                }
                else {
                    // error occurs
                    this._emit('error', `unexpected character "${c}"`);
                    // force consume
                    return true;
                }
            }
            else {
                this._state = retn.state;
                c === '\n' ? (this._line++, this._column = 0) : (this._column++);
                // character consumed
                return true;
            }
        }
    }
    accept(s: string){
        for(let i = s.length - 1; i >= 0; i--){
            this._inputBuf.push(s.charAt(i));
        }
        while(this._inputBuf.length > 0){
            this._acceptChar(this._inputBuf[this._inputBuf.length - 1]) && this._inputBuf.pop();
        }
    }
<% function printReduceActions(){
    let codegen = {
        addBlock(b: string, line: number){ %>
                <%- b.replace(/\$\$/g, prefix + 'top') %>
        <% },
        pushLexState(n: number){ %>
                this._lexState.push(<%- n.toString() %>);
        <% },
        popLexState(){ %>
                this._lexState.pop();
        <% },
        setImg(n: string){ %>
                this._setImg("<%- n %>");
        <% },
        returnToken(t: TokenDef){ %>
                this._token = {
                    id: <%- t.index.toString() %>,
                    val: this._matched.join('')
                };
        <% }
    };
    for(let rule of input.g.rules){
        if(rule.action !== null){ %>
            case <%- rule.index.toString() %>:
                /* <%- rule.toString() %> */
            <% for(let uvar in rule.vars){ %>
                var <%- uvar %> = this._sematicS[<%- prefix %>sp - <%- rule.rhs.length - rule.vars[uvar].val %>];
            <% }
            for(let uvar2 in rule.usedVars){ %>
                var <%- uvar2 %> = this._sematicS[<%- prefix %>sp - <%- rule.usedVars[uvar2].val %>];
            <% }
            for(let act of rule.action){
                act.toCode(codegen);
            } %>
                break;
        <% }
    }
} %>
    private _doReduction(<%- prefix %>rulenum: number){
        let <%- prefix %>nt = <%- prefix %>lhs[<%- prefix %>rulenum];
        let <%- prefix %>top = null;
        let <%- prefix %>sp = this._sematicS.length;
        switch(<%- prefix %>rulenum){
<% printReduceActions(); %>
        }
        this._lrState.length -= <%- prefix %>ruleLen[<%- prefix %>rulenum];
        let <%- prefix %>cstate = this._lrState[this._lrState.length - 1];
        this._lrState.push(<%- prefix %>pgoto[<%- prefix %>disgoto[<%- prefix %>cstate] + <%- prefix %>nt]);

        this._sematicS.length -= <%- prefix %>ruleLen[<%- prefix %>rulenum];
        this._sematicS.push(<%- prefix %>top);
    }

    private _acceptToken(t: Token){
        // look up action table
        let cstate = this._lrState[this._lrState.length - 1];
        let ind = <%- prefix %>disact[cstate] + t.id;
        let act = 0;
        if(ind < 0 || ind >= <%- prefix %>pact.length || <%- prefix %>checkact[ind] !== this._state){
            act = -<%- prefix %>defred[this._state] - 1;
        }
        else {
            act = <%- prefix %>pact[ind];
        }
        if(act > 0){
            // shift
            if(act === 1){
                this._accepted = true;
                return false;
            }
            else {
                this._lrState.push(act - 1);
                this._sematicS.push(t);
                // token consumed
                return true;
            }
        }
        else if(act < 0){
            this._doReduction(-act - 1);
        }
        else {
            // error
            this._emit("syntaxerror", `unexpected token ${<%- prefix %>tokenNames[t.id]}`);
            // force consume
            return true;
        }
    }
}
