import { TemplateInput, TemplateOutput } from '../def';
import { Item, Action } from '../../grammar/item-set';
import { Rule } from '../../grammar/grammar';
import { TokenDef } from '../../grammar/token-entry';
import { CodeGenerator } from '../code-generator';
import { DFA } from '../../lexer/dfa';
import { LexAction } from '../../lexer/action';
import { State, Arc } from '../../lexer/state';
import { Inf } from '../../util/interval-set';

export default function(input: TemplateInput, output: TemplateOutput){
echo("/*\n    generated by jscc, an LALR(1) parser generator made by hadroncfy\n*/\n");
let prefix = input.prefix;
let tab = input.opt.tab || '    ';
function echo(s: string){
    output.write(s);
}
function writeln(s: string){
    output.writeln(s);
}
function leftAlign(s: string, al: number): string{
    function repeat(s: string, t: number){
        let ret = '';
        while(t --> 0) ret += s;
        return ret;
    }
    return (s.length < al ? repeat(' ', al - s.length) : '') + s;
}
function printTable<T>(tname: string, t: T[], nl: number, mapper: (d: T) => string){
    let count = 0; 
echo("\nlet ");
echo(prefix + tname);
echo(" = [ \n    ");
for(let i of t){
        echo(leftAlign(mapper(i), nl));
        echo(',');
        count++ > 6 && (count = 0, echo(input.endl + tab));
    } 
echo("\n]; \n");
} 
echo("\n\n");
function printState(state: State<LexAction[]>){ 
    function arcToString(arc: Arc<LexAction[]>): string{
        let ret: string[] = [];
        arc.chars.forEach((from, to) => {
            let s: string[] = [];
            from !== Inf._oo && s.push(`c >= ${from}`);
            to !== Inf.oo && s.push(`c <= ${to}`);
            ret.push(s.join(' && '));
        });
        return ret.join(' || ');
    } 
    let first = true; 
echo("\n    case ");
echo(state.index.toString());
echo(":\n        ret.nfa = ");
echo(state.arcs.length > 0 && state.endAction !== null ? 'true' : 'false');
echo(";\n        ret.isEnd = ");
echo(state.endAction === null ? 'false' : 'true');
echo(";\n    ");
for(let arc of state.arcs){
        if(first) { 
echo("\n        if(");
echo(arcToString(arc));
echo("){\n            ret.state = ");
echo(arc.to.index.toString());
echo(";\n        }\n        ");
first = false;
        } else { 
echo("\n        else if(");
echo(arcToString(arc));
echo("){\n            ret.state = ");
echo(arc.to.index.toString());
echo(";\n        }\n        ");
}
    } 
    if(state.arcs.length === 0) { 
echo("\n        ret.state = -1;\n    ");
} else { 
echo("\n        else {\n            ret.state = -1;\n        }\n    ");
} 
echo("\n        break;\n");
} 
echo("\n\n");
function printDFA(dfa: DFA<LexAction[]>, n: number){ 
echo("\nfunction moveDFA");
echo(n.toString());
echo("(c: number, ret: { state: number, nfa: boolean, isEnd: boolean }){\n    switch(ret.state){\n        ");
for(let state of dfa.states){
            printState(state);
        } 
echo("\n        default:\n            ret.state = -1;\n            ret.nfa = false;\n    }\n}\n");
} 
echo("\n\n/*\n    find the next state to go in the dfa\n*/\n");
for(let i = 0, _a = input.dfas; i < _a.length; i++){
    printDFA(_a[i], i);
} 
echo("\n\n/*\n    all the lexer data goes here.\n*/\nlet ");
echo(prefix);
echo("lexers = [\n    ");
for(let i = 0;i < input.dfas.length;i++){ 
echo("\n    moveDFA");
echo(i.toString());
echo(",\n    ");
} 
echo("\n];\n\n");
let pt = input.pt; 
echo("\nlet ");
echo(prefix);
echo("stateCount = ");
echo(pt.stateCount.toString());
echo(";\n/*\n    compressed action table: action = ");
echo(prefix);
echo("pact[");
echo(prefix);
echo("disact[STATE-NUM] + TOKEN]\n    when action > 0, shift the token and goto state (action - 1);\n    when action < 0, reduce with rule (1-action);\n    when action = 0, do default action.\n*/\n");
printTable<Item>('pact', pt.pact, 6, t => {
    if(t === null || t === Item.NULL){
        return '0';
    }
    else if(t.actionType === Action.SHIFT){
        return (t.shift.stateIndex + 1).toString();
    }
    else if(t.actionType === Action.REDUCE){
        return (-t.rule.index - 1).toString();
    }
}); 
echo("\n/*\n    displacement of action table.\n*/\n");
printTable<number>('disact', pt.disact, 6, t => t.toString()); 
echo("\n/*\n    used to check if a position in ");
echo(prefix);
echo("pact is out of bouds.\n    if ");
echo(prefix);
echo("checkact[");
echo(prefix);
echo("disact[STATE-NUM] + TOKEN] = STATE-NUM, this position is not out of bounds.\n*/\n");
printTable<number>('checkact', pt.checkact, 6, t => t === undefined ? '0' : t.toString()); 
echo("\n/*\n    default action table. action = ");
echo(prefix);
echo("defred[STATE-NUM],\n    where action is the number of the rule to reduce with.\n*/\n");
printTable<number>('defred', pt.defred, 6, t => t.toString()); 
echo("\n/*\n    compressed goto table: goto = ");
echo(prefix);
echo("pgoto[");
echo(prefix);
echo("disgoto[STATE-NUM] + NON_TERMINAL]\n*/\n");
printTable<Item>('pgoto', pt.pgoto, 6, t => {
    if(t === null){
        return '-1';
    }
    else {
        return t.shift.stateIndex.toString();
    }
}); 
echo("\n/*\n    displacement of the goto table\n*/\n");
printTable<number>('disgoto', pt.disgoto, 6, t => t.toString()); 
echo("\n/*\n    length of each rule: rule length = ");
echo(prefix);
echo("ruleLen[RULE-NUM]\n*/\n");
printTable<Rule>('ruleLen', pt.g.rules, 6, r => r.rhs.length.toString()); 
echo("\n/*\n    index of the LHS of each rule\n*/\n");
printTable<Rule>('lhs', pt.g.rules, 6, r => r.lhs.index.toString()); 
echo("\n/*\n    token names\n*/\n");
printTable<TokenDef>('tokenNames', pt.g.tokens, 6, t => `"${t.sym}"`); 
echo("\n/*\n    token alias\n*/\n");
printTable<TokenDef>('tokenAlias', pt.g.tokens, 6, t => `"${t.alias}"` || '""'); 
echo("\n");
let className = input.opt.className || 'Parser'; 
echo("\n\n");
function printLexActionsFunc(dfa: DFA<LexAction[]>, n: number){
    let codegen = {
        addBlock(b: string, line: number){ 
echo("\n                ");
echo(b);
echo("\n        ");
},
        pushLexState(n: number){ 
echo("\n                this._lexState.push(");
echo(n.toString());
echo(");\n        ");
},
        popLexState(){ 
echo("\n                this._lexState.pop();\n        ");
},
        setImg(n: string){ 
echo("\n                this._setImg(\"");
echo(n);
echo("\");\n        ");
},
        returnToken(t: TokenDef){ 
echo("\n                this._token = {\n                    id: ");
echo(t.index.toString());
echo(",\n                    val: this._matched.join('')\n                };\n        ");
}
    }; 
    let statevn = prefix + 'staten'; 
echo("\n    private _doLexAction");
echo(n.toString());
echo("(");
echo(statevn);
echo(": number){\n        switch(");
echo(statevn);
echo("){\n            ");
for(let i = 0, _a = dfa.states; i < _a.length; i++){ 
                if(_a[i].endAction !== null){ 
echo("\n            case ");
echo(i.toString());
echo(":\n                    ");
for(let act of _a[i].endAction.data){
                        act(codegen);
                    } 
echo("\n                break;\n                ");
} 
echo("\n            ");
} 
echo("\n            default:;\n        }\n    }\n");
} 
echo("\n\ninterface Token{\n    id: number;\n    val: string;\n};\n\nexport class ");
echo(className);
echo(" {\n    // members for lexer\n    private _lexState: number[] = [];\n    private _state: number = 0;\n    private _matched: string[] = [];\n    private _token: Token = null;\n    private _marker: number = -1;\n    private _backup: string[] = [];\n\n    // members for parser\n    private _lrState: number[] = [];\n    private _sematicS: ");
echo(input.sematicType);
echo("[] = [];\n\n    private _setImg(s: string){\n        this._matched.length = 0;\n        for(let i = 0;i < s.length;i++){\n            this._matched.push(s.charAt(i));\n        }\n    }\n    ");
for(let i = 0, _a = input.dfas; i < _a.length; i++){
        printLexActionsFunc(_a[i], i);
    } 
echo("\n    ");
let lexstatevn = prefix + 'lexstate'; 
echo("\n    private _doLexAction(");
echo(lexstatevn);
echo(": number, ");
echo(prefix);
echo("state: number){\n        switch(");
echo(lexstatevn);
echo("){\n            ");
for(let i = 0;i < input.dfas.length;i++){ 
echo("\n            case ");
echo(i.toString());
echo(":\n                this._doLexAction");
echo(i.toString());
echo("(");
echo(prefix);
echo("state);\n                break;\n            ");
} 
echo("\n            default:;\n        }\n    }\n    private _acceptChar(c: number){\n        let lexstate = this._lexState[this._lexState.length - 1];\n        this._marker && this._backup.push(c);\n        let retn = { state: this._state, nfa: false, isEnd: false };\n        ");
echo(prefix);
echo("lexers[lexstate](c, retn);\n        if(retn.isEnd){\n\n        }\n    }\n}\n");


}